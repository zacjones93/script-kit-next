## 1) Critical issues

### A. `frontmost_app_tracker`: update logic ignores PID (stale app / stale menu cache)

Right now you decide whether to update tracking based only on `bundle_id`:

```rust
state.last_real_app.as_ref().map(|a| a.bundle_id != tracked.bundle_id)
```

That breaks in real life when:

* the same app quits and relaunches (same bundle id, new pid)
* a helper process briefly becomes “active” but you still want to refresh the menu owner
* PID reuse happens (rare, but it’s a thing over long runtimes)

**Impact:** you can hold a stale PID and/or stale cached menu items indefinitely.

**Fix:** include PID in the “should update” check.

```rust
let should_update = {
    let state = TRACKER_STATE.read();
    state.last_real_app.as_ref().map(|a| {
        a.bundle_id != tracked.bundle_id || a.pid != tracked.pid
    }).unwrap_or(true)
};
```

If you *intentionally* don’t want to refresh on PID changes, then you should at least refresh the menu cache when PID changes (because accessibility trees can differ after relaunch).

---

### B. `frontmost_app_tracker`: unbounded thread spawning on rapid app switching

Every activation can spawn a new thread to fetch menu items:

```rust
std::thread::spawn(move || { match get_menu_bar_for_pid(pid) { ... } });
```

If a user holds ⌘-Tab for a second, you can easily spawn dozens of threads doing heavy accessibility work. You do guard against stale writes (good), but you **don’t** prevent the work from piling up.

**Impact:** CPU spikes + memory pressure + possible UI hitching *exactly when users are switching apps* (worst time).

**Fix:** use a single worker (or small pool) + “keep only latest request” semantics. Details in recommendations section.

---

### C. `frontmost_app_tracker`: Objective‑C runtime class name is global and generic

You register an ObjC class named `"ScriptKitAppObserver"`.

That name lives in the global ObjC runtime namespace for the whole process. If you ever embed/compose components or load plugins that do similar things, collisions become real.

**Fix:** make the class name unique (e.g., include bundle id-ish prefix or a static unique suffix). Even `"SKGPUIAppObserver"` is a step up. (No runtime cost, just fewer landmines.)

---

### D. `frontmost_app_tracker`: panics are swallowed silently

You correctly prevent unwinding across FFI:

```rust
let _ = std::panic::catch_unwind(|| { ... });
```

…but you ignore the result. If anything panics, you get *no signal* except that events stop behaving correctly.

**Fix:** log when a panic happens:

```rust
if let Err(_) = std::panic::catch_unwind(|| { ... }) {
    logging::log("ERROR", "Panic in handle_app_activation callback");
}
```

---

### E. `system_actions`: module is macOS-only at runtime but not gated at compile/test

This file will compile on other platforms (it’s just `std::process::Command`), but:

* `osascript` won’t exist → runtime errors
* your unit tests call `run_applescript_with_output("return 42")` without `#[ignore]` and without `#[cfg(target_os = "macos")]`

**Impact:** CI or devs running tests on non-macOS will see failures.

**Fix:** add `#[cfg(target_os="macos")]` (or at least gate tests). Details below.

---

### F. `system_actions`: several AppleScript actions are brittle / likely to fail silently on some systems

Examples:

* `toggle_do_not_disturb()` relies on UI scripting + specific Control Center structure + English label `"Focus"`.
* `show_desktop()` uses `key code 103 using {command down}`. That’s not a universally reliable mapping to “Show Desktop”.

**Impact:** “works on my Mac” behavior, then users report random failures.

**Fix:** treat these as *best-effort* actions and surface “permission needed” or “not supported on this macOS” errors in a more user-facing way (even if the internal API still returns `Result<(), String>`).

---

## 2) Performance concerns

### A. Cloning menu items on every read

```rust
pub fn get_cached_menu_items() -> Vec<MenuBarItem> {
    TRACKER_STATE.read().cached_menu_items.clone()
}
```

If `MenuBarItem` is non-trivial (it usually is), this is a “hidden tax” every time UI renders or a command reads menu items.

**Fix:** store the cache behind `Arc<Vec<MenuBarItem>>` and return an `Arc`. Zero-copy reads, and it’s safe.

---

### B. Logging volume in hot paths

You log on every app activation and sometimes “Script Kit (ignoring)”.

If the logger is synchronous or if formatting happens eagerly, you’ll feel it. At minimum, don’t log “ignoring” at info-level.

**Fix:** make noisy paths `debug!` or sample them.

---

### C. Spawning `osascript` per action is expensive

This is acceptable for infrequent actions (lock screen, sleep, restart). It is **not** acceptable if you ever wire “volume up” or “toggle mute” into rapid repeats, or system-event triggers that can fire often.

**Fix options (pick one):**

1. Keep as-is but ensure these actions run off the UI thread (mandatory).
2. Add a small “osascript worker” that serializes AppleScripts (prevents process spawn storms).
3. Long-term: replace with native APIs for common actions.

---

### D. No timeouts for AppleScript execution

A hung `osascript` call can hang a calling thread forever.

**Fix:** add an execution timeout (even 2–5 seconds) and kill the process if it exceeds it.

---

## 3) API design feedback

### A. Frontmost tracker should expose “updates” as events, not just polling getters

You’ve already built something that conceptually emits events (activation events), but your API is “pull”:

* `get_last_real_app()`
* `get_cached_menu_items()`

Given your next feature bundle (SystemEventBus), this is begging to be unified:

* frontmost app activation → `SystemEvent::AppActivated { ... }`
* menu cache ready → `SystemEvent::MenuCacheUpdated { bundle_id, count }` (optional)

**Recommendation:** treat `frontmost_app_tracker` as a *producer* into your global event bus (even if you still keep the current getters for backwards compatibility).

---

### B. `system_actions` returning `Result<(), String>` is okay externally, but weak internally

Strings are fine for script-facing UX, but they’re bad for:

* diagnostics
* analytics/telemetry
* user guidance (“needs Accessibility permission” vs “syntax error”)

**Recommendation:** use a typed internal error and convert to `String` at the boundary.

---

### C. Event triggers: allowlist built-ins (don’t make everything triggerable)

For the System Events feature, if you let “any built-in command” run on sleep/wake/network changes, you’ll end up with:

* accidental destructive automations
* hard-to-debug loops (event triggers command triggers event triggers …)

**Recommendation:** define an allowlist of “safe to run unattended” commands, and require explicit user opt-in for anything else.

---

## 4) Simplification opportunities

### A. Replace “spawn a thread per fetch” with a single fetch worker

This simplifies correctness and improves performance.

It also simplifies your state: you probably don’t need `fetching_bundle_id` if the worker itself always processes “latest request only” (you’ll still want “currently fetching X” for debug).

---

### B. Store observer + run loop logic in one dedicated “macOS notifications thread” module

Right now the observer setup is embedded in the tracker module. That’s okay for one notification type, but you’re about to add many (sleep/wake, mounts, screen lock, etc).

**Recommendation:** create one macOS event thread that registers all observers and pushes events into your event bus. Then `frontmost_app_tracker` becomes a subscriber that maintains derived state (last app + cached menu items).

This will make Feature Bundle 32 much easier.

---

### C. Reduce brittleness in AppleScripts by factoring UI-scripting scripts into “best-effort” category

Separate:

* reliable Apple Events APIs
* brittle UI automation scripts that require Accessibility + can break with localization

Then your app can message the user correctly (“grant permission” vs “macOS changed UI element”).

---

## 5) Specific recommendations with concrete code changes

### 5.1 Fix PID refresh bug in frontmost tracking

Update the `should_update` logic:

```rust
let should_update = {
    let state = TRACKER_STATE.read();
    state.last_real_app.as_ref().map(|a| {
        a.bundle_id != tracked.bundle_id || a.pid != tracked.pid
    }).unwrap_or(true)
};
```

And consider also storing a “last_seen_at” timestamp to help debug weird transitions.

---

### 5.2 Replace unbounded menu fetch threads with a single coalescing worker

**Goal:** Always fetch for the most recent activation, drop intermediate requests.

A simple pattern (bounded channel of size 1 + try_send + drain):

```rust
use std::sync::OnceLock;
use crossbeam_channel::{bounded, Sender, Receiver};

#[derive(Clone)]
struct MenuFetchReq {
    pid: i32,
    bundle_id: String,
}

static MENU_FETCH_TX: OnceLock<Sender<MenuFetchReq>> = OnceLock::new();

fn init_menu_fetch_worker() {
    let (tx, rx): (Sender<MenuFetchReq>, Receiver<MenuFetchReq>) = bounded(1);
    let _ = MENU_FETCH_TX.set(tx);

    std::thread::spawn(move || {
        while let Ok(mut req) = rx.recv() {
            // Coalesce: keep draining so we only do work for the latest request
            while let Ok(next) = rx.try_recv() {
                req = next;
            }

            // Now do exactly one fetch
            fetch_menu_items_sync(req.pid, req.bundle_id);
        }
    });
}

fn request_menu_fetch(pid: i32, bundle_id: String) {
    if let Some(tx) = MENU_FETCH_TX.get() {
        // If the queue is full, drop the old request and replace it:
        // easiest approach: try_send; if it fails, ignore (worker will fetch latest anyway soon)
        let _ = tx.try_send(MenuFetchReq { pid, bundle_id });
    }
}

fn fetch_menu_items_sync(pid: i32, bundle_id: String) {
    // this is basically your fetch_menu_items_async body, but without spawning
    // and with the same "only write if still tracking" guard
}
```

**Notes:**

* This requires `crossbeam-channel` (small, solid dependency).
* If you don’t want a new dependency, you can do similar with `std::sync::mpsc`, but coalescing is clunkier.

---

### 5.3 Stop cloning menu items; return `Arc<Vec<MenuBarItem>>`

Change state:

```rust
use std::sync::Arc;

#[derive(Default)]
struct TrackerState {
    last_real_app: Option<TrackedApp>,
    cached_menu_items: Arc<Vec<MenuBarItem>>,
    fetching_bundle_id: Option<String>,
}
```

Initialize with `Arc::new(Vec::new())` in `Default`.

Getter becomes:

```rust
pub fn get_cached_menu_items() -> Arc<Vec<MenuBarItem>> {
    TRACKER_STATE.read().cached_menu_items.clone()
}
```

When updating:

```rust
state.cached_menu_items = Arc::new(items);
```

**Impact:** you remove a potentially expensive clone from every read path.

---

### 5.4 Ensure Objective‑C thread doesn’t silently leak / silently die

At minimum:

* log panics
* create an autorelease pool around setup work

Example:

```rust
extern "C" fn handle_app_activation(_this: &Object, _sel: Sel, notification: *mut Object) {
    let result = std::panic::catch_unwind(|| {
        objc::rc::autoreleasepool(|| unsafe {
            handle_app_activation_inner(notification)
        });
    });

    if result.is_err() {
        logging::log("ERROR", "Panic in NSWorkspace activation handler");
    }
}
```

For setup, wrap the *setup portion* in an autorelease pool. Don’t wrap an infinite `run` call in one pool (it won’t drain). Do:

```rust
unsafe {
    objc::rc::autoreleasepool(|| {
        // build class, alloc/init observer, register
    });

    // then run loop
    let run_loop: *mut Object = msg_send![Class::get("NSRunLoop").unwrap(), currentRunLoop];
    let _: () = msg_send![run_loop, run];
}
```

(Your callback already uses an autorelease pool; that’s good.)

---

### 5.5 Gate `system_actions` by platform + fix tests

For functions:

```rust
#[cfg(target_os = "macos")]
pub fn sleep() -> Result<(), String> { ... }

#[cfg(not(target_os = "macos"))]
pub fn sleep() -> Result<(), String> {
    Err("sleep is only supported on macOS".to_string())
}
```

For tests that call `osascript`:

```rust
#[cfg(target_os = "macos")]
#[test]
fn test_run_applescript_with_output_simple() {
    ...
}
```

Or mark them `#[ignore]` by default, but gating is cleaner.

---

### 5.6 Add timeouts to AppleScript execution

If you keep spawning processes, you need a kill path. A practical approach is:

* `Command::spawn()`
* wait with timeout
* if timeout, kill + return error

This typically needs a helper crate (because stable Rust doesn’t include timed wait). If you don’t want deps, run AppleScript on a background thread and enforce timeout at a higher level (still leaves the process running, which is not great).

**Tell it like it is:** without timeouts, you’ll eventually get a “why did Script Kit hang?” bug report that you can’t reproduce.

---

### 5.7 Improve AppleScript error messages for permissions

When UI scripting fails, users usually need Accessibility permission. You can detect common failure patterns in stderr and return a more actionable string, e.g.:

* “not authorized to send Apple events…”
* “System Events got an error…”

Even a basic mapping will reduce support load.

---

## Decisions for Feature Bundle 32 (based on your constraints)

You asked key questions; here are answers that won’t sabotage launcher performance or script compatibility:

1. **Battery event granularity**
   Default: **threshold + rate-limited**, not per 1%.

* Emit `BatteryLevelChanged` only when:

  * crossing configured thresholds (20/10/5), and/or
  * changed by ≥ 5% since last emit, and no more frequently than e.g. once per minute
    Allow power users to opt into “every 1%” if they want it.

2. **Blocking vs async on `onWillSleep`**
   Don’t block system sleep for user scripts. It’s a reliability trap.
   If you want “must run before sleep,” reserve it for **built-ins only**, with a hard cap (sub-second) and fail-open.

3. **Which built-ins should be triggerable**
   Allowlist only:

* clear clipboard history / clear sensitive items
* hide/show Script Kit windows
* pause/resume watchers
* rotate logs, vacuum SQLite, prune caches (maintenance)
  Avoid enabling anything that can log out / restart / shut down without a user confirmation gate.

4. **Should scripts register their own listeners (`onSystemEvent`)**
   Not in v1 if you’re launching Bun per script invocation. Long-lived listeners imply a long-lived runtime and lifecycle management (restart, crash, upgrades).
   Stick to config-based bindings first. Later you can add “daemon scripts” as an explicit opt-in category.

5. **Network debouncing**
   Coalesce changes and emit the stable state:

* debounce window ~ 750ms–2000ms
* emit “final” state after quiet period
* always include a snapshot payload (connected + interface + optional SSID) so scripts don’t have to query synchronously

---

If you implement only two changes immediately: **(1) coalesced menu fetch worker** and **(2) PID-aware updates**, you’ll eliminate the biggest correctness + performance risks in the code shown.
