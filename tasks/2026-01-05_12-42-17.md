## 1) Critical issues

### A. **`ScriptWatcher` can spam `FullReload` (and/or reload many times)**

Right now, any “unknown” `notify::EventKind` becomes `ScriptReloadEvent::FullReload`, **but it’s still stored per-path** in `pending`. That means a rename-heavy operation (git checkout, branch switch, editor atomic renames, mass moves) can lead to **many FullReload emissions after debounce**, unless you happen to hit the storm threshold first.

**Impact**

* Repeated expensive reloads (script index rebuilds, UI refresh) → stutter / jank.
* Hard-to-debug behavior: “why did it reload 12 times?”

**Fix**
Treat `FullReload` as a **global state**, not a per-path pending item. Concretely: if you ever decide `FullReload` is needed, clear `pending` and schedule a single `FullReload` emission.

Example patch pattern (drop-in idea):

```rust
let mut pending: HashMap<PathBuf, (ScriptReloadEvent, Instant)> = HashMap::new();
let mut full_reload_at: Option<Instant> = None;

fn next_global_deadline(
    pending: &HashMap<PathBuf, (ScriptReloadEvent, Instant)>,
    full_reload_at: Option<Instant>,
    debounce: Duration,
) -> Option<Instant> {
    let per_file = next_deadline(pending, debounce);
    let full = full_reload_at.map(|t| t + debounce);
    match (per_file, full) {
        (None, None) => None,
        (Some(a), None) => Some(a),
        (None, Some(b)) => Some(b),
        (Some(a), Some(b)) => Some(a.min(b)),
    }
}

// In the event loop, when mapping to reload_event:
match reload_event {
    ScriptReloadEvent::FullReload => {
        pending.clear();
        full_reload_at = Some(Instant::now());
    }
    other => {
        pending.insert(path.clone(), (other, Instant::now()));
    }
}

// On timeout:
flush_expired(&mut pending, debounce, &out_tx);

if let Some(t) = full_reload_at {
    if Instant::now().duration_since(t) >= debounce {
        let _ = out_tx.send(ScriptReloadEvent::FullReload);
        full_reload_at = None;
    }
}
```

Also: **if `full_reload_at.is_some()` you can ignore further per-file events** until it fires, which prevents extra work during storms.

---

### B. **Atomic-save / rename patterns can be misclassified**

Many editors save by writing a temp file and renaming, or by remove+create sequences. Your mapping:

* `Create(_)` → `FileCreated`
* `Remove(_)` → `FileDeleted`
* `Modify(_)` → `FileChanged`
* everything else → `FullReload`

This can produce weird sequences like `FileDeleted(path)` then `FileCreated(path)` for a plain edit, and if you later implement incremental reload strictly (“created means new”), you’ll get incorrect behavior.

**Impact**

* Incremental reload correctness risk.
* Script list churn / flicker (remove then add).
* Downstream logic becomes complicated.

**Fix options (pick one):**

1. **Merge create/delete pairs into “changed”** within the debounce window for the same path.
2. Introduce a single semantic event like `Upsert(PathBuf)` for “file exists and may have changed,” and keep delete separate.
3. If you keep the current enum, treat `FileCreated` as “upsert” downstream (don’t assume it’s truly new).

A simple merge in the watcher (option #1) looks like:

```rust
fn merge_script_event(prev: Option<&ScriptReloadEvent>, next: ScriptReloadEvent, path: &PathBuf) -> ScriptReloadEvent {
    match (prev, &next) {
        (Some(ScriptReloadEvent::FileDeleted(_)), ScriptReloadEvent::FileCreated(_)) => {
            ScriptReloadEvent::FileChanged(path.clone())
        }
        (Some(ScriptReloadEvent::FileCreated(_)), ScriptReloadEvent::FileDeleted(_)) => {
            // editor temp swap can look like this; treat as changed unless you *know* it’s real delete
            ScriptReloadEvent::FileChanged(path.clone())
        }
        _ => next,
    }
}
```

Then when inserting:

```rust
let prev = pending.get(path).map(|(ev, _)| ev);
let merged = merge_script_event(prev, reload_event, path);
pending.insert(path.clone(), (merged, Instant::now()));
```

---

### C. **Event storms are capped in `pending`, but NOT capped in the control channel**

You protect `pending` via `STORM_THRESHOLD`, but the **unbounded `std::sync::mpsc::channel`** between notify callback → watch loop can still accumulate thousands of `ControlMsg::Notify` messages during a storm. Even after you collapse to `FullReload`, you still have to *drain* a massive queue, which can:

* spike memory
* keep the watcher thread busy for a long time
* delay “real” events after a storm

**Fix**
Use a **bounded channel** and drop/coalesce at the boundary.

Minimal-change approach: replace `std::sync::mpsc` for the control channel with `crossbeam_channel::bounded`, and in the notify callback use `try_send` (drop if full). This is exactly the right place to drop events because you already have a safe fallback (`FullReload`).

Sketch:

```rust
let (control_tx, control_rx) = crossbeam_channel::bounded::<ControlMsg>(4096);

let mut watcher = recommended_watcher(move |res| {
    let _ = control_tx.try_send(ControlMsg::Notify(res));
})?;
```

Then replace `recv_timeout` usage accordingly (`crossbeam_channel` has it).

---

### D. **Appearance watcher is expensive + noisy on non-macOS**

`defaults read -g AppleInterfaceStyle` every 2 seconds spawns a process forever. It’s also macOS-specific but not `cfg`’d, so on Linux/Windows it will repeatedly fail to spawn `defaults` (still costs something), even though it stabilizes after emitting Light once.

**Impact**

* background CPU wakeups + process spawn overhead
* 0–2 second latency on theme changes (noticeable in a UI app)
* useless activity on non-macOS

**Fix**

* Gate with `#[cfg(target_os="macos")]`.
* Replace polling with native notification (your proposal is the right direction).

At minimum (even before NSDistributedNotificationCenter), change to:

* detect once at startup
* then **poll much less frequently** (e.g., 10–30s) unless you’re in dev mode

But the real fix is notifications (details in section 5C).

---

### E. **Backoff never “recovers”**

`attempt` grows monotonically across restarts. If you hit a few errors early (or while the folder doesn’t exist), backoff can become large and stay large even after things settle.

**Impact**

* unnecessary slow recovery later

**Fix**
Reset `attempt = 0` after a “healthy” period. A cheap heuristic:

* record `started_at = Instant::now()` before `watch_loop`
* on error, if `started_at.elapsed() > 30s`, treat it as healthy and reset `attempt = 0`

---

## 2) Performance concerns

### A. **Logging at `info!` for high-frequency events**

For scripts you log per event emission:

```rust
info!(event = ?ev, "Emitting script reload event");
```

During real development, this can become *a lot* of formatted output.

**Fix**

* Use `debug!` for per-file events.
* Keep `info!` for “mode changes”: “collapsed to FullReload”, “started watching extensions”, “watcher restarted”.

### B. **Extra PathBuf cloning**

In `ScriptWatcher` you clone paths multiple times:

* iterate `event.paths.iter()` (borrow)
* `path.clone()` for event variant
* `path.clone()` again for HashMap key

**Fix**
Move out of `event.paths` to take ownership and reduce clones:

```rust
for path in event.paths.into_iter() {
    if !is_relevant_script_file(&path) { continue; }
    // use `path` as the key, clone only if you must embed it elsewhere
}
```

Then store *kind* in the map rather than storing an event that already owns a cloned path (see 5B).

### C. **Recursive watch without directory ignore list**

Watching `scripts/` recursively without ignoring directories like `node_modules`, `.git`, `target`, `.DS_Store`-heavy dirs, etc., is asking for storms. Even if users “shouldn’t” put those there, someone will.

**Fix**
Add a path ignore predicate:

```rust
fn is_ignored_path(path: &std::path::Path) -> bool {
    path.components().any(|c| {
        matches!(c.as_os_str().to_str(),
            Some("node_modules" | ".git" | "target" | ".idea" | ".vscode"))
    })
}
```

and check it before `is_relevant_script_file`.

---

## 3) API design feedback

### A. **Your watcher types are 80% duplicated**

`ConfigWatcher` and `ThemeWatcher` are near-identical: same supervisor, same debounce, same stop/join logic, different target path and output event type.

**Better abstraction**
Create a single generic `SingleFileWatcher<E>`:

* takes `target_path`
* takes `map_event: Fn(&notify::Event) -> bool` (or “touches target?” predicate)
* outputs a fixed event `E` (e.g., `Reload`)

That cuts a lot of code and makes future additions (AssetWatcher) cheaper and less bug-prone.

### B. **Script event enum may be too “filesystem literal”**

The variants (Created/Changed/Deleted) are filesystem-level. What the app likely wants is **semantic**:

* “script definition may have changed” (upsert)
* “script removed”
* “many changes, rebuild index”

If you push filesystem-literal semantics outward, you’re forcing the rest of the app to deal with atomic-save weirdness.

**Recommendation**
Either:

* change API to `Upsert(PathBuf) | Delete(PathBuf) | FullReload`, or
* keep current enum but *promise* that Created/Changed both mean upsert.

### C. **Consider batching**

Right now you may emit multiple events back-to-back after a quiet period. If the consumer reacts by doing expensive work per event, you’ll get redundant reload work.

Two good patterns:

1. Drain-and-coalesce at receiver side (`try_iter()` until empty, then handle once).
2. Change the watcher to emit a batch (`Vec<ScriptDelta>`) after debounce.

Given your perf constraints, batching is usually the right move.

---

## 4) Simplification opportunities

### A. Remove dead “Stop” plumbing or make it real

`ControlMsg::Stop` exists but is never sent. You rely entirely on `stop_flag` and timeouts to unblock `recv_timeout`. That’s fine, but the enum branch is dead complexity.

**Two clean options**

* Remove `ControlMsg::Stop` entirely.
* Or store a `control_tx` in the watcher struct and send `Stop` in `Drop` for immediate wake-up.

### B. Centralize supervisor + debounce policy

You have:

* supervisor (backoff, restart)
* debounce policy (trailing edge)
* storm policy (threshold)
  implemented in different ways per watcher.

If you centralize those policies into reusable helpers, the file shrinks and behavior becomes consistent.

---

## 5) Specific recommendations (concrete code changes)

### 5A. Make `FullReload` global and single-shot

Implement the `full_reload_at` approach described in **1A**. This is the #1 correctness/perf fix for script reload.

Also change the “unknown event kind” fallback to:

* immediately schedule global full reload
* **do not** insert per-path pending items

### 5B. Store “pending kind” rather than cloning the whole event

This reduces clones and makes merging easier.

Example:

```rust
#[derive(Clone, Copy, Debug)]
enum PendingKind { Upsert, Delete }

let mut pending: HashMap<PathBuf, (PendingKind, Instant)> = HashMap::new();

match kind {
    notify::EventKind::Create(_) | notify::EventKind::Modify(_) => {
        pending.insert(path, (PendingKind::Upsert, Instant::now()));
    }
    notify::EventKind::Remove(_) => {
        pending.insert(path, (PendingKind::Delete, Instant::now()));
    }
    notify::EventKind::Access(_) => {}
    _ => { /* schedule FullReload globally */ }
}

// When flushing:
for (path, (kind, _)) in expired {
    let ev = match kind {
        PendingKind::Upsert => ScriptReloadEvent::FileChanged(path),
        PendingKind::Delete => ScriptReloadEvent::FileDeleted(path),
    };
    let _ = out_tx.send(ev);
}
```

Notice: “upsert” maps to `FileChanged` here intentionally — it avoids the atomic-save “created” trap.

### 5C. Replace appearance polling with native notification (worth it)

Yes: it’s worth it, **if** you keep it contained and behind `cfg(target_os="macos")`.

My practical recommendation: **use a tiny ObjC shim** and call it from Rust. That’s lower-risk than fighting the Rust Cocoa bindings in the hot path.

Shape:

* `appearance_observer.m` registers `NSDistributedNotificationCenter` observer for `"AppleInterfaceThemeChangedNotification"`.
* On callback, query the current mode (via `NSUserDefaults` / appearance API) and call a Rust `extern "C"` function with `bool is_dark`.
* Rust pushes `AppearanceChangeEvent` to the channel.

Then:

* On non-macOS: either disable the watcher or keep a slow poll fallback.

This eliminates the `defaults` process spawn and gives instant updates.

### 5D. Add ignore rules and “asset watcher” using the same generic machinery

Once you have a generic directory watcher, AssetWatcher is cheap.

Asset filter example:

```rust
fn is_relevant_asset(path: &Path) -> bool {
    matches!(path.extension().and_then(|e| e.to_str()),
        Some("svg") | Some("json") | Some("tmTheme") | Some("plist"))
}
```

And emit:

```rust
pub enum AssetReloadEvent {
    FileChanged(PathBuf),
    FullReload,
}
```

### 5E. Make `dev.sh` more informative and less trigger-happy

Right now it rebuilds on “anything cargo-watch decides”, and you don’t capture timings.

A better dev loop with timing + “why did it rebuild”:

```bash
cargo watch -c --why \
  -w src -w Cargo.toml -w Cargo.lock \
  -i target \
  -s 'echo "=== $(date) ==="; time cargo run'
```

Then, layer in your dev feature:

```bash
-s 'echo "=== $(date) ==="; time cargo run --features fast-dev'
```

Optional: detect sccache in the script and set `RUSTC_WRAPPER=sccache`.

---

## Answers to your “Key Questions” (opinionated + practical)

1. **Build time optimization**

* **sccache** is usually the biggest win if you rebuild often and especially if you have multiple crates.
* **Split debuginfo** can help link times on macOS; it’s worth trying in `profile.dev`.
* Incremental is typically already on for dev; the real bottleneck is often **linking** and **proc-macro churn**.

2. **Hot reload granularity**

* Do per-script reload for `Upsert(path)` and `Delete(path)`.
* Keep `FullReload` as a safe fallback for rename storms / schema changes / bulk ops.
* Don’t try to be “perfectly incremental” from day 1 — be incremental for the common case, safe for the weird case.

3. **Appearance detection**

* Yes, native notification is worth it. Polling + process spawn is objectively the wrong long-term solution for a UI app.

4. **Asset pipeline**

* For dev: **runtime reload** (no Rust rebuild).
* For prod: embed defaults, allow disk overrides + runtime reload for user-provided assets.

5. **Dev UX HUD**

* Default: **silent** for fast frequent reloads (scripts/theme).
* Show HUD/toast only for:

  * reload failures
  * reloads that took “too long” (e.g., >150ms)
  * `FullReload` events (since they’re heavier and rarer)
    Make it a dev-only toggle so it doesn’t annoy you during heavy editing.
