Below is a focused review of `src/ai/config.rs` with the highest-impact issues first, then concrete changes you can drop in.

---

## 1) Critical Issues

### 1. Secrets will leak via `Debug` (this is a real footgun)

You derive `Debug` for both `ProviderConfig` and `DetectedKeys`, and both contain API keys as `String`. Rust’s derived `Debug` prints private fields too.

That means any `log::debug!("{:?}", detected_keys)` or panic output could dump real keys into logs, bug reports, CI output, etc.

**Why this is critical:** it’s not hypothetical—people log configs all the time during setup flows and “why isn’t my key detected?” debugging.

**Fix:** either remove `Debug` derives from secret-bearing structs, or implement redacting Debug manually (best).

---

### 2. Your “prevent copies of the key” comment is misleading (and currently false)

`ProviderConfig::api_key()` returns `&str` “to prevent accidental copies”… but:

* `ProviderConfig` derives `Clone` → cloning duplicates the secret in memory.
* Consumers can still `.to_string()` the `&str` anyway.

This isn’t a correctness bug, but it’s a **security-model mismatch** between docs and reality, and it will lead to complacency.

---

### 3. Tests give a false sense of coverage around env detection

`test_detected_keys_empty` says “Clear any existing env vars for this test” but it doesn’t clear anything and doesn’t call `DetectedKeys::from_environment()` at all. It just checks `DetectedKeys::default()`.

So you are **not testing** the env scanning code path, which is the entire point of this module.

Also: env var mutation in tests is process-global and can race if tests run in parallel. So if you *do* add env var tests naïvely, you can introduce intermittent failures.

---

### 4. Model IDs are likely to drift and you have a future mismatch baked in

Your Anthropic default model IDs include the dated suffix (`claude-3-5-sonnet-20241022`), while your project-level config example uses `"claude-3-5-sonnet"`.

If other parts of the app assume the short alias, this will cause:

* default model not found in picker lists
* failure to route model selection
* “works on my machine” config weirdness when model strings don’t match

At minimum, you should plan for **aliases** (map “friendly/short IDs” → “provider actual IDs”) or standardize one canonical format everywhere.

---

## 2) Performance Concerns (relevant to “60fps list scroll” + “instant launcher”)

This file can absolutely become a hidden perf tax if you call these helpers in render loops or on every window open.

### 1. `default_models::*()` allocates every call

Each call creates:

* a new `Vec`
* multiple heap `String`s (`id`, `display_name`, `provider`)

If your UI rebuilds model lists frequently (theme reload, window init, model picker open), this is avoidable churn and can show up as micro-stutter.

**Fix:** cache once and return a slice.

---

### 2. `DetectedKeys::from_environment()` should not run in hot paths

`env::var` isn’t “slow” in absolute terms, but it is definitely not free, and it’s easy to call it too often when building reactive state.

**Fix:** compute once at startup (or configuration reload), store in app state, and only rescan on explicit “Reload config/env” actions.

---

## 3) API Design Feedback (better patterns / safer abstractions)

### 1. Introduce a “secret” type instead of raw `String`

Right now secrets are a plain `String` in multiple places, which makes it too easy to:

* accidentally log them
* accidentally serialize them later
* clone them everywhere

Two solid approaches:

**A) Lightweight: roll your own newtype**

* controls `Debug`
* can control cloning behavior
* can add `zeroize` later

**B) Use a battle-tested crate**

* `secrecy::SecretString` (common in Rust ecosystems)
* optionally combine with `zeroize`

Either way, the important part is: **make it hard to print a key by accident.**

---

### 2. Don’t hardcode provider detection into a fixed struct as you scale

`DetectedKeys` is fine for 5 providers. With Vercel gateway + BYOK + custom gateway URL + direct fallbacks, this struct will balloon.

You’ll want either:

* a structured “env config” object (`DetectedEnvAiConfig`) that reflects your actual needs, or
* a normalized map of provider → secret, plus separate “routing config” values (gateway URL, etc.)

This becomes especially important for “Auto” provider logic and for setup UX (“what is missing?”).

---

### 3. Consider `Url` parsing once, not passing around strings

`base_url: Option<String>` is fine for storage, but any consumer building HTTP clients should parse/validate once and store a `Url` (or store the parsed form in the runtime provider).

This prevents:

* repeated parsing
* runtime errors later
* subtle mistakes like missing scheme

---

## 4) Simplification Opportunities

### 1. Remove repetition in `from_environment()`

You repeat this pattern 5 times:

```rust
env::var(env_vars::OPENAI_API_KEY).ok().filter(|s| !s.is_empty())
```

Make a helper and use it everywhere (and include `.trim()` so `"   "` doesn’t count as a key).

---

### 2. Consolidate default models into cached statics

You can drastically reduce allocations by caching the vectors and returning `&'static [ModelInfo]`.

---

### 3. Fix tests by removing env dependency entirely

The clean solution is dependency injection: make env-reading pluggable so tests don’t mutate global process state.

---

## 5) Specific Recommendations (concrete code changes)

### A) Redact secrets and stop deriving `Debug` on secret structs

#### Option 1: Manual `Debug` implementations (no new crates)

```rust
use std::fmt;

#[derive(Clone)]
pub struct ProviderConfig {
    pub provider_id: String,
    pub display_name: String,
    api_key: String,
    pub base_url: Option<String>,
}

impl fmt::Debug for ProviderConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("ProviderConfig")
            .field("provider_id", &self.provider_id)
            .field("display_name", &self.display_name)
            .field("api_key", &"<redacted>")
            .field("base_url", &self.base_url)
            .finish()
    }
}

#[derive(Default)]
pub struct DetectedKeys {
    pub openai: Option<String>,
    pub anthropic: Option<String>,
    pub google: Option<String>,
    pub groq: Option<String>,
    pub openrouter: Option<String>,
}

impl fmt::Debug for DetectedKeys {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Only show presence/absence, never values
        f.debug_struct("DetectedKeys")
            .field("openai", &self.openai.is_some())
            .field("anthropic", &self.anthropic.is_some())
            .field("google", &self.google.is_some())
            .field("groq", &self.groq.is_some())
            .field("openrouter", &self.openrouter.is_some())
            .finish()
    }
}
```

This single change closes the biggest leak vector immediately.

#### Option 2: Newtype for keys (strongly recommended as you add Vercel + BYOK)

```rust
use std::fmt;

#[derive(Clone)]
pub struct ApiKey(String);

impl ApiKey {
    pub fn new(raw: String) -> Option<Self> {
        let trimmed = raw.trim().to_string();
        if trimmed.is_empty() { None } else { Some(Self(trimmed)) }
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Debug for ApiKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("<api-key:redacted>")
    }
}
```

Then change your structs to `Option<ApiKey>` / `api_key: ApiKey`.

---

### B) Fix env var reading with a helper (trim + single source of truth)

```rust
fn read_env_nonempty(name: &str) -> Option<String> {
    std::env::var(name)
        .ok()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
}
```

Then:

```rust
pub fn from_environment() -> Self {
    Self {
        openai: read_env_nonempty(env_vars::OPENAI_API_KEY),
        anthropic: read_env_nonempty(env_vars::ANTHROPIC_API_KEY),
        google: read_env_nonempty(env_vars::GOOGLE_API_KEY),
        groq: read_env_nonempty(env_vars::GROQ_API_KEY),
        openrouter: read_env_nonempty(env_vars::OPENROUTER_API_KEY),
    }
}
```

If you move to `ApiKey`, swap the helper to return `Option<ApiKey>`.

---

### C) Cache default models to avoid repeated allocations

If these are used by the UI at all, stop allocating them repeatedly.

```rust
use std::sync::OnceLock;

pub mod default_models {
    use super::ModelInfo;
    use std::sync::OnceLock;

    static OPENAI: OnceLock<Vec<ModelInfo>> = OnceLock::new();

    pub fn openai() -> &'static [ModelInfo] {
        OPENAI.get_or_init(|| {
            vec![
                ModelInfo::new("gpt-4o", "GPT-4o", "openai", true, 128_000),
                ModelInfo::new("gpt-4o-mini", "GPT-4o Mini", "openai", true, 128_000),
                ModelInfo::new("gpt-4-turbo", "GPT-4 Turbo", "openai", true, 128_000),
                ModelInfo::new("gpt-3.5-turbo", "GPT-3.5 Turbo", "openai", true, 16_385),
            ]
        })
    }

    // Repeat for other providers
}
```

This helps “instant launcher” because it avoids allocator churn when opening windows / pickers.

---

### D) Make env detection testable without global env mutation

Introduce an env abstraction.

```rust
use std::env::VarError;

pub trait Env {
    fn var(&self, key: &str) -> Result<String, VarError>;
}

pub struct StdEnv;

impl Env for StdEnv {
    fn var(&self, key: &str) -> Result<String, VarError> {
        std::env::var(key)
    }
}

fn read_env_nonempty_from<E: Env>(env: &E, name: &str) -> Option<String> {
    env.var(name)
        .ok()
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
}

impl DetectedKeys {
    pub fn from_env<E: Env>(env: &E) -> Self {
        Self {
            openai: read_env_nonempty_from(env, env_vars::OPENAI_API_KEY),
            anthropic: read_env_nonempty_from(env, env_vars::ANTHROPIC_API_KEY),
            google: read_env_nonempty_from(env, env_vars::GOOGLE_API_KEY),
            groq: read_env_nonempty_from(env, env_vars::GROQ_API_KEY),
            openrouter: read_env_nonempty_from(env, env_vars::OPENROUTER_API_KEY),
        }
    }

    pub fn from_environment() -> Self {
        Self::from_env(&StdEnv)
    }
}
```

Then in tests, use a fake env:

```rust
use std::collections::HashMap;
use std::env::VarError;

struct FakeEnv(HashMap<String, String>);

impl super::Env for FakeEnv {
    fn var(&self, key: &str) -> Result<String, VarError> {
        self.0.get(key).cloned().ok_or(VarError::NotPresent)
    }
}

#[test]
fn detects_openai_key() {
    let mut map = HashMap::new();
    map.insert(super::env_vars::OPENAI_API_KEY.to_string(), "sk-test".to_string());
    let env = FakeEnv(map);

    let keys = super::DetectedKeys::from_env(&env);
    assert!(keys.openai.is_some());
}
```

Now your tests are deterministic and parallel-safe.

---

### E) Prep this module for Vercel Gateway + BYOK without it becoming a mess

Add env vars, but don’t keep bolting fields onto `DetectedKeys` forever.

At minimum, introduce a separate struct for Vercel:

```rust
pub mod env_vars {
    pub const VERCEL_API_KEY: &str = "SCRIPT_KIT_VERCEL_API_KEY";
    pub const VERCEL_GATEWAY_URL: &str = "SCRIPT_KIT_VERCEL_GATEWAY_URL";
    pub const VERCEL_OPENAI_KEY: &str = "SCRIPT_KIT_VERCEL_OPENAI_KEY";
    pub const VERCEL_ANTHROPIC_KEY: &str = "SCRIPT_KIT_VERCEL_ANTHROPIC_KEY";

    // existing...
}
```

And a dedicated detected config:

```rust
#[derive(Default)]
pub struct DetectedVercel {
    pub api_key: Option<String>,
    pub gateway_url: Option<String>,
    pub byok_openai: Option<String>,
    pub byok_anthropic: Option<String>,
}

impl DetectedVercel {
    pub fn from_environment() -> Self {
        Self {
            api_key: read_env_nonempty(env_vars::VERCEL_API_KEY),
            gateway_url: read_env_nonempty(env_vars::VERCEL_GATEWAY_URL),
            byok_openai: read_env_nonempty(env_vars::VERCEL_OPENAI_KEY),
            byok_anthropic: read_env_nonempty(env_vars::VERCEL_ANTHROPIC_KEY),
        }
    }
}
```

Then you can implement “auto provider selection” cleanly by combining:

* `DetectedVercel`
* `DetectedKeys` (direct)

…and keep backward compatibility without shoving everything into one struct.

---

## What I’d change first (highest ROI in your constraints)

1. **Remove/replace `Debug` derives for any struct holding keys** (ProviderConfig + DetectedKeys). This is the biggest “oops I leaked user secrets” risk.

2. **Cache the default model lists** if they’re used anywhere in UI or setup flows.

3. **Refactor env detection to be testable** (Env trait) so you can confidently add Vercel vars and not fight flaky tests.

4. **Decide on canonical model IDs + aliases now** (especially around Anthropic short vs dated IDs) before Vercel routing introduces even more naming layers.
