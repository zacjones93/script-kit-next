Below is a straight, actionable review of `src/hud_manager.rs`, with the biggest correctness problems first, then performance/API/simplification, and concrete changes you can make.

---

## 1. Critical issues

### A) **Queued action HUDs lose their action**

**Bug:** `cleanup_expired_huds` always calls `show_hud(...)`, even if the pending item was created by `show_hud_with_action`.

```rust
show_hud(pending.text, Some(pending.duration_ms), cx);
```

So anything queued from `show_hud_with_action` will later display as a plain HUD (no button, no action).

**Fix:** Route pending notifications through a single “show notification” function that preserves `action_label` and `action`.

---

### B) **Action HUDs are fundamentally unclickable**

You always do:

```rust
let _: () = msg_send![window, setIgnoresMouseEvents: true];
```

That makes the window click-through. No button will ever receive clicks, so the GPUI `.on_click(...)` handler is dead code right now.

**Fix:** set `ignoresMouseEvents` based on whether the HUD has an action, OR accept that action HUDs should not be click-through.

---

### C) **You close/configure the wrong HUD when multiple are stacked**

Both `configure_hud_window_by_bounds` and `close_hud_window_by_bounds` match only:

* width
* height
* **x**
* (tolerance)

They **do not match y**, and stacked HUDs share width/height/x.

Result: if you have 2–3 HUDs stacked, a timer firing for “HUD #3” can close “HUD #1” (or just whichever NSWindow happens to appear first in `[NSApp windows]`). This will desync your `active_huds` tracking and cause “ghost slots” that block the queue.

**Fix (minimum):** include **y** in the matching criteria.

**Fix (real):** stop identifying windows by bounds at all. Use a stable identifier (id/title/representedURL) or keep a direct handle/pointer.

---

### D) **AppKit calls are likely happening off the main thread**

In the timer task you do:

```rust
cx.spawn(async move |cx: &mut gpui::AsyncApp| {
    Timer::after(duration_duration).await;

    close_hud_window_by_bounds(cleanup_bounds); // <-- AppKit scan + close
    let _ = cx.update(|cx| cleanup_expired_huds(cx));
})
```

Anything that touches AppKit (`NSApp`, enumerating windows, closing windows) must happen on the main thread. In most UI runtimes, `AsyncApp` tasks are not guaranteed to run on the main thread except inside `cx.update(...)`.

**Fix:** move *all* AppKit work inside `cx.update(...)` (or better: avoid AppKit entirely for close by closing through GPUI).

This is a crash-risk / undefined behavior issue.

---

### E) **Your expiry logic can leak `active_huds` entries forever**

```rust
self.created_at.elapsed().as_millis() as u64 > self.duration_ms
```

Problems:

* `as_millis()` truncates.
* you use `>` not `>=`.

It’s entirely possible for the timer to fire, you call cleanup, and `elapsed_millis == duration_ms`, meaning **not expired**, so you don’t remove it. If no other cleanup runs later, that entry sticks forever and the queue eventually stops working.

**Fix:** compare `Duration` directly and use `>=`.

---

### F) **`dismiss_all_huds` doesn’t dismiss anything visually**

It only clears the tracking vectors:

```rust
state.active_huds.clear();
state.pending_queue.clear();
```

It does **not** close windows. So you can end up with orphan HUD windows still on screen while the manager thinks none exist.

**Fix:** actually close each active window (and ensure any timers won’t resurrect state / attempt double-close).

---

### G) **Window configuration is racy and fragile**

Right after `open_window` you scan `[NSApp windows]` trying to find “your” HUD by bounds. That can fail if:

* GPUI hasn’t created/registered the NSWindow yet when you scan
* coordinate units don’t match the way you assume (points vs pixels, rounding, backing scale factor)
* another window coincidentally matches your dimensions

When it fails, you log “Could not find HUD window…” and the HUD stays unconfigured (wrong level, wrong behavior).

**Fix:** configure the window via a direct window reference, not a global scan. If GPUI doesn’t expose it, that’s the abstraction gap you should close.

---

## 2. Performance concerns

### A) Creating/destroying windows per HUD is expensive

Even with MAX=3, if scripts spam HUDs you’re doing:

* a new GPUI window creation
* an AppKit scan/configure
* a timer task
* another AppKit scan/close

This is not catastrophic for occasional HUDs, but it’s easy for user scripts to accidentally call this at high frequency. You’ll get jank.

**Better:** a single overlay window rendering a list of HUDs (or a small window pool reused).

---

### B) Repeated `[NSApp windows]` scans are O(N) and unsafe-heavy

Both configure and close enumerate every NSWindow. That’s unnecessary work and one of the riskiest parts of the code.

---

### C) The global `Mutex` is probably unnecessary

`show_hud` requires `&mut App`, which usually implies “UI thread only.” If that’s true, you can store state in an app-global model (no mutex) and simplify a lot. If it’s not true, then you *already* have a bigger problem: HUD requests should be marshaled onto the UI thread, not locking a mutex around UI state.

---

### D) Hard-coded styling fights theme hot-reload

You’re using fixed colors:

```rust
.bg(rgb(0x1e1e1e))
.text_color(rgb(0xFFFFFF))
```

That means HUD won’t follow theme changes (one of your key constraints). It also makes cross-window theme hot reload irrelevant for HUDs.

---

## 3. API design feedback

### A) You have two “show” functions with duplicated logic

`show_hud` and `show_hud_with_action` duplicate:

* queue checks
* position calc
* window open
* tracking
* timer scheduling
* cleanup

This duplication is already causing the queued-action bug.

**Fix:** unify into one internal function that takes `HudNotification` (or an enum describing the variant).

---

### B) Your internal tracking doesn’t track what you actually need

You store a `WindowHandle` but don’t use it to close/reposition; instead you close by scanning AppKit windows.

If you can’t safely close via the handle today, that’s a sign you need:

* a stable HUD id
* a close API that runs on UI thread
* (optionally) a native window pointer you can configure *without scanning*

---

### C) Lack of stable IDs makes cleanup brittle

Bounds matching is not an identifier. Use an `id: u64` and thread it through:

* active list
* timers
* dismiss calls

---

## 4. Simplification opportunities

### The cleanest design: **single overlay window per display**

Instead of “one NSWindow per HUD”, do:

* One always-on-top transparent overlay window (per display, or just per “mouse display”).
* The overlay window renders a vertical stack of HUD toasts in one GPUI view.
* Adding/removing notifications is just updating view state.
* Auto-dismiss: schedule removals by id (or maintain an expiry heap and tick).
* Click handling becomes sane: you can decide per-toast whether it’s clickable.

This eliminates:

* window scanning
* window matching hacks
* most of the race conditions
* most of the unsafe surface area

If you want MAX_SIMULTANEOUS_HUDS=3, you can still enforce it in the model and render at most 3.

---

### If you insist on multiple windows: use a pool

Pre-create 3 HUD windows on startup (or lazily) and reuse them:

* show = update view + reposition + orderFront
* hide = orderOut (or close and recreate later)
  This reduces churn and makes behavior consistent.

---

## 5. Specific recommendations with concrete code changes

### Step 1: Fix the “expiry” bug immediately

```rust
impl ActiveHud {
    fn is_expired(&self) -> bool {
        self.created_at.elapsed() >= Duration::from_millis(self.duration_ms)
    }
}
```

This alone prevents “active list never shrinks” failures.

---

### Step 2: Fix queued action HUDs by unifying the show path

Create a single internal function:

```rust
fn show_notification(notif: HudNotification, cx: &mut App) {
    if notif.action.is_some() && notif.action_label.is_some() {
        show_hud_with_action(
            notif.text,
            Some(notif.duration_ms),
            notif.action_label.unwrap(),
            notif.action.unwrap(),
            cx,
        );
    } else {
        show_hud(notif.text, Some(notif.duration_ms), cx);
    }
}
```

Then in `cleanup_expired_huds`:

```rust
while state.active_huds.len() < MAX_SIMULTANEOUS_HUDS {
    if let Some(pending) = state.pending_queue.pop_front() {
        drop(state);
        show_notification(pending, cx);
        state = manager.lock();
    } else {
        break;
    }
}
```

This fixes functionality without a big refactor.

(Then later, remove the duplication entirely—this is just a minimal corrective patch.)

---

### Step 3: Stop making action HUDs click-through

Change `configure_hud_window_by_bounds` to accept a flag:

```rust
fn configure_hud_window_by_bounds(expected_bounds: gpui::Bounds<Pixels>, click_through: bool) {
    ...
    let _: () = msg_send![window, setIgnoresMouseEvents: click_through /* but see BOOL note below */];
}
```

And call it like:

* normal HUD: `click_through = true`
* action HUD: `click_through = false`

Also: don’t pass Rust `true/false` to AppKit BOOL casually—use the proper BOOL type/values in your wrapper (even if it “works” today, it’s sloppy ABI hygiene).

---

### Step 4: Fix “wrong window closes” (minimum viable fix)

If you keep bounds matching, **include Y** in configure and close:

```rust
let expected_y: f32 = expected_bounds.origin.y.into();
let y_match = (frame.origin.y - expected_y as f64).abs() < 5.0;

if w_match && h_match && x_match && y_match {
    ...
}
```

This still isn’t great, but it stops the guaranteed failure when stacking.

---

### Step 5: Move AppKit calls onto the UI thread

Right now you do AppKit work before `cx.update`.

Do this instead:

```rust
cx.spawn(async move |cx: &mut gpui::AsyncApp| {
    Timer::after(duration_duration).await;

    let _ = cx.update(|cx| {
        // Do *all* close + state cleanup on UI thread
        close_hud_window_by_bounds(cleanup_bounds);
        cleanup_expired_huds(cx);
    });
}).detach();
```

This is a correctness fix. It reduces crash risk.

---

### Step 6: Make dismiss actually dismiss

Implement “dismiss all” to close windows too. If you can’t close via `WindowHandle`, you’ll have to close via native calls (but then you need a reliable mapping).

If GPUI provides a close API on the handle (or via `App`), do it:

```rust
pub fn dismiss_all_huds(cx: &mut App) {
    let windows: Vec<_> = {
        let manager = get_hud_manager();
        let mut state = manager.lock();
        let handles = state.active_huds.iter().map(|h| h.window).collect::<Vec<_>>();
        state.active_huds.clear();
        state.pending_queue.clear();
        handles
    };

    for handle in windows {
        // Pseudocode – depends on GPUI API:
        // handle.close(cx);
        // or cx.close_window(handle);
    }
}
```

If you *cannot* close via handle, that’s exactly why you should refactor away from “close by scanning NSApp windows”.

---

### Step 7: Add a stable HUD id + cancel-safe timers

Even with the fixes above, you still have timer/dismiss races. The simplest robust pattern:

* assign `hud_id`
* timer fires → `cx.update` checks “is this hud_id still active?” before closing/removing
* manual dismiss removes it; timer becomes a no-op

Sketch:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
static NEXT_HUD_ID: AtomicU64 = AtomicU64::new(1);

struct ActiveHud {
    id: u64,
    window: WindowHandle<HudView>,
    expires_at: Instant,
}

fn dismiss_hud(id: u64, cx: &mut App) {
    let handle = {
        let manager = get_hud_manager();
        let mut state = manager.lock();
        if let Some(i) = state.active_huds.iter().position(|h| h.id == id) {
            Some(state.active_huds.swap_remove(i).window)
        } else {
            None
        }
    };

    if let Some(handle) = handle {
        // close via GPUI handle if possible
    }

    cleanup_expired_huds(cx);
}
```

Timer task:

```rust
cx.spawn(async move |cx: &mut gpui::AsyncApp| {
    Timer::after(duration).await;
    let _ = cx.update(|cx| dismiss_hud(id, cx));
}).detach();
```

This completely avoids “timer closes the wrong thing” as long as your close mechanism is tied to the right handle/id.

---

## Direct answers to your 5 expert questions

### 1) Separate NSWindows vs single overlay window?

**Single overlay window wins** for your constraints:

* fewer native windows
* easier stacking/layout/animation
* easier theme hot-reload (one view)
* easier click handling (per-toast)
* massively smaller unsafe surface area

Separate windows *can* work, but your current “identify by bounds” approach is a reliability trap.

---

### 2) Safely wrap Cocoa window manipulation without raw `msg_send!`?

Two practical approaches:

* **Best:** switch to typed Objective‑C bindings (e.g., the modern Rust Objective‑C wrapper ecosystem) and keep the AppKit surface small. This reduces calling convention footguns.
* **Also fine:** keep `msg_send!` but hide it behind a tiny module with:

  * “main thread only” enforcement
  * correct ObjC types (BOOL/NSInteger/NSUInteger)
  * no scanning/matching hacks (operate on a known window pointer)

Right now you have unsafe calls sprinkled across logic *and* you’re doing global window enumeration, which is the worst combination.

---

### 3) Correct cleanup pattern for async-scheduled destruction?

Use **id-based ownership + UI-thread close**:

* schedule timer
* on fire: `cx.update`:

  * check still present by id
  * close that specific window (handle or pointer)
  * remove from active list
  * show next queued

No “search by bounds,” no cross-thread AppKit calls, no reliance on time-based `retain` filtering.

---

### 4) How do other apps do clickable + auto-dismiss?

Common patterns:

* **System notifications** (UserNotifications): clickable actions, OS-managed dismissal, respects Focus modes.
* **Custom toast windows**: not click-through, often *non-activating panels*, with:

  * click anywhere to open/dismiss
  * hover to pause auto-dismiss
  * small close button

Your current design (“click-through window with a button”) is a contradiction: you have to pick which behavior you want.

---

### 5) Should you use macOS UserNotifications instead?

Use UserNotifications when you want:

* persistence (Notification Center)
* action buttons that work reliably
* OS behavior (Do Not Disturb, Focus, grouped notifications)
* delivery when your UI isn’t frontmost

Don’t use it as a drop-in replacement for Raycast-style “HUD” feedback:

* it’s not instant/ephemeral in the same way
* it can be suppressed by Focus/DND
* it requires user permission
* it doesn’t look/feel like “showHUD”

A good compromise: **keep custom HUD for quick ephemeral messages**, and use **UserNotifications for actionable/persistent alerts**.

---

## What I’d do next (most impact, least churn)

1. Fix `is_expired` (`Duration` + `>=`).
2. Fix queued action HUDs (unify “show pending” path).
3. Fix click-through for action HUDs.
4. Move AppKit calls into `cx.update` (main thread).
5. Stop identifying windows by bounds (add hud_id + close via handle/pointer).
6. Longer-term: replace per-HUD windows with a single overlay window rendering a stack.

If you want, I can propose a concrete “single overlay window” design in GPUI terms (state model + view + show/hide policy) that drops most of the current complexity and makes actions/theme straightforward.
