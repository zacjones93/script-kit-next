## 1. Critical issues

### A) Cursor blink can run while the window is *not* focused

Your blink loop only checks:

* `is_main_window_visible()`
* `focused_input != FocusedInput::None`

…but it does **not** check `platform::is_main_window_focused()`.

That means in non‑dismissable views (notably `TermPrompt` and `EditorPrompt`), the main window can remain visible while unfocused, and you’ll still:

* flip `cursor_visible`
* call `cx.notify()`
* potentially update `ActionsDialog`

This is both a UX bug (caret blink while not active) and wasted work.

**Action:** gate blink on window focus too.

```rust
// inside the blink timer update closure
if !script_kit_gpui::is_main_window_visible()
    || !platform::is_main_window_focused()
    || app.focused_input == FocusedInput::None
{
    return;
}
```

### B) Focus state is duplicated and will drift

Right now you have at least three sources of truth:

* `focused_input: FocusedInput` (manual + InputEvent-driven)
* `gpui_input_focused: bool` (InputEvent-driven)
* real focus state (`focus_handle.is_focused(window)`)

This is already showing up in comments like “belt-and-suspenders” and the reset hack to get the cursor back.

**What breaks next:** a prompt/view that steals focus without updating `focused_input` → caret blink and focus styles desync.

**Action:** pick one truth and derive the rest.

* For **styling**: don’t store focus booleans at all (use GPUI focus tracking styles, see section 3).
* For **cursor blink**: either derive from actual focus (best) or centralize *all* focus transitions through one function that also updates `focused_input`.

### C) You’re “fixing” lack of window access by enforcing focus every render

In `Render::render`, you do:

* check `is_window_focused`
* for the current view, check `is_focused`
* if not, call `focus(...)`

That works, but it has two sharp edges:

1. **It will steal focus from future UI elements.**
   You already had to special-case `FormPrompt` to avoid stealing focus from text fields.

2. **It can create focus thrash.**
   If `is_focused(window)` doesn’t update immediately after a focus call on some platforms, you’ll spam `window.focus(...)` across frames.

**Action:** switch to a “pending focus request” model (apply focus once, not perpetually). You can still keep a small “safety check” for truly broken states, but don’t use render as your primary focus enforcer.

---

## 2. Performance concerns

### A) `current_view.clone()` inside `render()` is a serious hot-path cost

You explicitly clone `self.current_view` every render “to call &mut self methods”.

That means, per frame / per keystroke / per cursor blink tick, you may clone:

* `Vec<Choice>` for `ArgPrompt`
* large `entries` lists for clipboard/apps/windows
* `String`s, etc.

This is **way more expensive than cloning a FocusHandle** and is likely to show up as stutter long before you hit GPU limits.

**Action options (pick one):**

1. **Store heavy prompt payloads behind `Arc`** so clones are cheap.

   ```rust
   ArgPrompt {
       id: Arc<str>,
       placeholder: Arc<str>,
       choices: Arc<[Choice]>,
       actions: Arc<[ProtocolAction]>,
   }
   ```

2. **Split “view tag” from “view data”**:

   * `current_view: AppViewKind` (no big owned data)
   * `arg_prompt_state: Option<ArgPromptState>` stored on `self`

3. **Refactor render dispatch** so you don’t need to clone the enum:

   * move render functions to free functions / helper modules that take explicit references, not `&mut self`
   * or restructure borrowing so the match doesn’t hold an immutable borrow across `&mut self` calls

If you do only one perf fix from this review, do this one.

### B) Blink timer forces full app re-render

You toggle `cursor_visible` on the app state and call `cx.notify()`. That invalidates the whole tree (and triggers the `current_view.clone()` problem above).

**Action:** once you fix `current_view.clone()`, this becomes “acceptable”. Until then, blink will amplify the cost.

---

## 3. API design feedback

### 1) Central focus manager vs per-component FocusHandles?

**Don’t replace per-component FocusHandles.** In GPUI, FocusHandle is the primitive and should stay local to the focusable thing.

But you *do* want a **central focus policy layer** in `ScriptListApp` that answers:

* “What should be focused right now?”
* “What should be focused after I close an overlay?”
* “If view changes without window access, what focus should be applied on next render?”

That’s not a global focus manager; it’s a small orchestrator.

### 2) Make focus-aware styling less boilerplate

You’re currently doing `is_focused` → `theme.get_colors(is_focused)` everywhere.

GPUI already has first-class support for focus-aware styling:

* `.track_focus(&FocusHandle)` to subscribe an element to focus state
* `.focus(|style| ...)` and `.in_focus(|style| ...)` to apply styles when focused/within focused

This is exactly what you want. It removes:

* extracting `is_focused` before closures
* manually triggering re-render on focus change for styling

**Net:** you stop plumbing `bool` everywhere.

### 3) GPUI-idiomatic tab navigation between sibling components

Use built-in **tab stops** + **tab groups**:

* `FocusHandle.tab_stop(true)` / `.tab_index(...)` exist for tab order control
* Zed added **tab groups** to make sane tabbing possible without hand-maintaining indices.

Your forms are the exact use case Zed describes.

### 4) Cursor blink: focus-tied or separate?

Tie blink **to focus + window focus**. Caret blink is a presentation detail driven by focus state.

Make “blink service” separate, but driven by:

* “Do we currently have a caret?”
* “Is the window focused?”

Right now you tied it to `focused_input`, but that enum is too small for your app (forms, editor, terminal).

### 5) How does Zed handle focus transitions?

Two relevant patterns from Zed’s own write-up:

* They use `FocusHandle` as the low-level primitive.
* For large forms, they introduced **tab groups** so most keyboard navigation is defined declaratively in the UI tree, not in per-component key handlers.

That’s the direction you want for FormPrompt and other multi-field prompts.

---

## 4. Simplification opportunities

### A) Introduce a `pending_focus` request instead of focusing in render forever

Add a field:

```rust
enum FocusTarget {
    MainFilter,
    AppRoot,
    ActionsDialog,
    PathPrompt,
    FormPrompt,
    EditorPrompt,
    // you can add: Terminal, NextFormField, etc.
}

pending_focus: Option<FocusTarget>,
focus_stack: Vec<FocusTarget>, // optional, for overlays
```

Then:

* When state changes without window access (e.g. `handle_prompt_message`), set `pending_focus = Some(...)`.
* In `render()`, apply focus **once** when `pending_focus` is set, then clear it.

This eliminates a lot of “if not focused, focus” checks, and it stops you from fighting future components.

### B) Stop using `FocusedInput` as a catch-all focus model

If you keep it, make it strictly “caret owner” and rename it to something like:

* `CaretOwner`
* `BlinkOwner`

And expand it to cover the real set (FormField, Editor, Terminal) *or* derive it from actual focus state.

### C) Use GPUI focus styling instead of passing booleans

You can keep `theme.get_colors(bool)` for now, but stop wiring the bool through render trees.

Compute both variants once per render and apply via focus styles.

---

## 5. Specific recommendations with concrete code changes

### Recommendation 1: Fix cursor blink gating and correctness

Minimal change, high value:

```rust
// In blink timer
if !script_kit_gpui::is_main_window_visible()
    || !platform::is_main_window_focused()
    || app.focused_input == FocusedInput::None
{
    return;
}
```

Also consider: if actions dialog is open, you probably want blink only if *its* input is focused (or if it owns caret).

### Recommendation 2: Add a “pending focus” mechanism (apply once)

In `ScriptListApp`:

```rust
enum FocusTarget {
    MainFilter,
    AppRoot,
    ActionsDialog,
    PathPrompt,
    FormPrompt,
    EditorPrompt,
}

impl ScriptListApp {
    fn request_focus(&mut self, target: FocusTarget, cx: &mut Context<Self>) {
        self.pending_focus = Some(target);
        cx.notify();
    }

    fn apply_pending_focus(&mut self, window: &mut Window, cx: &mut Context<Self>) {
        if !platform::is_main_window_focused() {
            return;
        }
        let Some(target) = self.pending_focus.take() else { return };

        match target {
            FocusTarget::MainFilter => {
                let input_state = self.gpui_input_state.clone();
                input_state.update(cx, |state, cx| state.focus(window, cx));
            }
            FocusTarget::ActionsDialog => {
                if let Some(ref dialog) = self.actions_dialog {
                    let fh = dialog.read(cx).focus_handle.clone();
                    window.focus(&fh, cx);
                }
            }
            FocusTarget::EditorPrompt => {
                if let AppView::EditorPrompt { entity, .. } = &self.current_view {
                    entity.update(cx, |editor, cx| editor.focus(window, cx));
                }
            }
            FocusTarget::PathPrompt => {
                if let AppView::PathPrompt { focus_handle, .. } = &self.current_view {
                    window.focus(focus_handle, cx);
                }
            }
            FocusTarget::FormPrompt => {
                if let AppView::FormPrompt { entity, .. } = &self.current_view {
                    let fh = entity.read(cx).focus_handle(cx);
                    window.focus(&fh, cx);
                }
            }
            FocusTarget::AppRoot => {
                window.focus(&self.focus_handle, cx);
            }
        }
    }
}
```

Then, at the top of `render()` (after `is_window_focused` check), do:

```rust
if platform::is_main_window_focused() {
    self.apply_pending_focus(window, cx);
}
```

Now you can **delete or drastically reduce** the per-view “if not focused then focus” block.

Where to call `request_focus`:

* `show_main_window_helper`: request MainFilter (or ActionsDialog depending on state)
* `toggle_actions` open: push previous focus to stack, request ActionsDialog
* `toggle_actions` close: pop and request previous focus
* in `handle_prompt_message`: when you set `current_view`, also `request_focus(...)`

### Recommendation 3: Replace focus-aware color plumbing with `track_focus` + `.focus()` styles

Instead of:

* compute `is_focused`
* pass it down
* call `get_colors(is_focused)`

Do:

```rust
let normal = self.theme.get_colors(false);
let focused = self.theme.get_colors(true);

div()
    .track_focus(&self.focus_handle) // subscribes to focus state 
    .bg(normal.background)
    .border_color(normal.border)
    .focus(|s| s.border_color(focused.border))
    .child(/* ... */)
```

This eliminates your “FocusHandle in closures” problem for styling, because you’re no longer extracting a bool and threading it everywhere.

Also: `.in_focus(|...|)` is useful for containers that should highlight when any child is focused.

### Recommendation 4: Implement form Tab navigation using tab groups, not manual cycling

In your form prompt root container, add `.tab_group()`.

Then ensure each field is a tab stop and uses tab_index in the “0 / -1 world”.

Zed’s approach:

* use `tabindex`-like behavior
* add *tab groups* to reset indices locally

GPUI side:

* `FocusHandle.tab_stop` and `tab_index` exist

Concretely, you want:

* Form root: `.tab_group()`
* Each input: tab_stop(true), tab_index(0)
* Anything you want skipped: tab_stop(false) (or tab_index(-1) depending on your wrapper)

This avoids writing bespoke Tab handling per form and scales to “N fields”.

### Recommendation 5: Fix the biggest perf footgun: stop cloning the whole view every render

This is focus-adjacent because your blink + focus changes cause renders.

Do one of:

* Move heavy prompt payloads behind `Arc`
* Separate view kind from view data

Example (separate view kind + state):

```rust
enum AppViewKind { ScriptList, ArgPrompt, FormPrompt, EditorPrompt, /* ... */ }

struct ScriptListApp {
    current_view: AppViewKind,
    arg_prompt: Option<ArgPromptState>,
    // ...
}

struct ArgPromptState {
    id: String,
    placeholder: String,
    choices: Arc<[Choice]>,
    actions: Option<Arc<[ProtocolAction]>>,
}
```

Now render can match on `current_view` without cloning large vectors.

---

## URLs

```text
https://docs.rs/gpui/latest/gpui/struct.FocusHandle.html
https://docs.rs/gpui/latest/gpui/struct.Svg.html
https://zed.dev/blog/settings-ui
```
