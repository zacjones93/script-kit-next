## 1) Critical Issues

### A. Window bounds are **not saved** on the common close paths

Right now bounds are only saved in `close_notes_window()` / `close_ai_window()`. But users can close windows via:

* traffic light (red close button)
* `Cmd+W` (you explicitly handle this in both windows by calling `window.remove_window()`)
* Notes “toggle close” path inside `open_notes_window()` (existing handle branch)

None of those save bounds. That means window position/size persistence is basically random depending on *how* the user closes it.

**Fix direction**
You need a single lifecycle hook that runs on **any** close path. If GPUI exposes a close event, hook it. If not, store bounds in the view during render and persist changes with a debounce (see Recommendations section for a concrete pattern).

---

### B. AI theme watcher is a **task leak** (and can become many watchers)

`open_ai_window()` spawns a theme watcher every time it creates a *new* AI window. If the user closes/reopens AI multiple times, you accumulate multiple background tasks watching the same file forever.

Those tasks:

* keep polling every 200ms
* keep doing `sync_gpui_component_theme(cx)` on theme changes
* never stop when AI closes (they just do nothing when handle is `None`)

Notes tried to guard with `NOTES_THEME_WATCHER_RUNNING`; AI has no equivalent. This is a real leak.

**Fix direction**
Single theme watcher process for the whole app (ThemeService), broadcasting to windows. Do not run one watcher per window.

---

### C. Theme hot reload does **not** update cached shadows (your UI lies after theme changes)

Both `AiApp` and `NotesApp` cache box shadows at construction:

* `cached_box_shadows = Self::compute_box_shadows();`
* `render()` always uses `self.create_box_shadows()` (clone of cached)

Theme watcher only does:

* `sync_gpui_component_theme(cx)`
* `cx.notify()` on the window

It never calls `AiApp::update_theme()` / `NotesApp::update_theme()`. So after theme.json changes, shadows remain stale until the window is destroyed and recreated.

**Fix direction**
Either:

* remove the cache and compute from in-memory theme each render (only OK if cheap), or
* introduce a “theme revision” and recompute cached values when revision changes (recommended), or
* have ThemeService call into each window to update caches (harder without entity refs).

---

### D. `is_*_window_open()` can return incorrect results and can panic

Both:

```rust
pub fn is_ai_window_open() -> bool {
    let window_handle = AI_WINDOW.get_or_init(|| std::sync::Mutex::new(None));
    let guard = window_handle.lock().unwrap();
    guard.is_some()
}
```

Problems:

* `unwrap()` can panic if the mutex is poisoned.
* `Some(handle)` doesn’t guarantee the handle is still valid. The handle can become invalid (window closed) but still stored until something clears it. You *already* have validity probing code in open functions; the “is open” helpers should use the same logic or be replaced by registry validity checks.

**Fix direction**

* Never `unwrap()` on these globals.
* Prefer `WindowRegistry::get_valid(role, cx)` that probes and auto-clears stale handles.

---

### E. You have **two different “WindowRole” enums** (registry vs window_state)

`src/windows/registry.rs` defines:

```rust
pub enum WindowRole { Main, Notes, AiChat }
```

But you also call:

```rust
crate::window_state::WindowRole::Ai
crate::window_state::WindowRole::Notes
```

That’s a recipe for accidental mismatches and duplicated mapping glue.

**Fix direction**
Use a single canonical window role type across:

* handle registry
* bounds persistence
* theme broadcast targeting
* logging

If you need different semantics, rename them explicitly (`WindowRole` vs `PersistedWindowRole`) and centralize mapping in one place (not scattered).

---

### F. AI streaming tasks can keep the view alive after window close

You spawn async work capturing `this` (an entity reference) and you also spawn a background thread. If the window closes mid-stream, the entity may stay alive until the stream completes, meaning:

* `Drop` may not run promptly
* the global handle may not be cleared promptly
* “is open” checks can be wrong for a while

This isn’t theoretical; long-running streams or hung provider calls can make it persistent.

**Fix direction**
Use weak references / cancellation tokens so closing the window cancels streaming and releases the entity promptly.

---

## 2) Performance Concerns

### A. AI streaming update loop is doing **O(n²)** work for long messages

You maintain `shared_content: Arc<Mutex<String>>` and every ~50ms you:

* clone the entire buffer into `current`
* assign `app.streaming_content = current`

As output grows, cloning grows, and total cost becomes quadratic-ish over time.

**Better pattern**
Stream incremental chunks through a channel and append in the UI, or track `last_len` and only append the delta.

---

### B. Repeated `load_theme()` calls inside render paths

Notes and AI vibrancy helpers call `crate::theme::load_theme()` repeatedly during render (and in multiple helper functions). If `load_theme()` hits disk or does heavy parsing, you’re toast. If it’s cached, you’re still doing unnecessary calls and copies.

**Fix direction**
Load once per render and reuse derived colors/opacities.

---

### C. Multiple independent theme watcher loops polling every 200ms

Even “only 5Hz” becomes noisy if you accidentally spawn multiple tasks (AI) or later add more windows.

**Fix direction**
Single ThemeService watcher. No polling loops per window.

---

### D. `Arc<Mutex<...>>` polled every render in Notes

`drain_pending_action()` and browse drains lock multiple mutexes every render. Probably fine for Notes, but if you reuse this pattern in the main launcher list (60fps), it will show up.

**Fix direction**
Use GPUI-native messaging/subscription when possible, or a single channel, or store pending state in the view itself (not Arc/Mutex), and only use Arc/Mutex when truly cross-thread.

---

## 3) API Design Feedback

### 1. Make `WindowRegistry` the single source of truth for handles

Yes: **global singleton registry** is the right move here. Per-window `OnceLock<Mutex<Option<WindowHandle>>>` is duplicated state with inconsistent behaviors.

What the registry needs beyond what you have now:

* **validity-aware get**

  * “If update fails, auto-clear and return None”
* **take/remove**

  * atomically remove handle so close paths can’t double-use it
* **update helper**

  * `with_window(role, cx, |root, window, cx| ...) -> bool`

This prevents every window module from re-implementing the same “release lock before update” dance.

---

### 2. Builder pattern: don’t overbuild—start with a “spec struct + helper”

A full “SecondaryWindowBuilder” can be fine, but you can keep it tight:

* a `SecondaryWindowSpec` struct with:

  * role
  * title
  * default bounds function
  * `WindowOptions` builder
  * `build_root` closure
  * optional hooks: `on_opened`, `on_existing`, `post_native_config`
* plus a single helper: `open_or_activate(spec, cx)`

That’s enough to eliminate 80% of duplication without turning your window system into a framework.

---

### 3. Vibrancy helpers: yes, `ui_foundation.rs` should be canonical

At minimum:

* `hex_to_rgba_with_opacity` should only exist once (already in `ui_foundation.rs`)

But note: your window modules are also duplicating *“get bg color + apply opacity”* logic. I’d pull that into a small shared helper too.

---

### 4. `compute_box_shadows()` should not live in each window module

Yes, move it, but I’d be careful about where:

* If `Theme` is meant to be UI-agnostic, don’t stick `gpui::BoxShadow` into it.
* Better: `crate::theme::ui::{box_shadows(theme: &Theme) -> Vec<BoxShadow>}` or `theme/gpui_integration.rs`

If you already allow UI types in `Theme`, then `Theme::box_shadows()` is fine.

---

### 5. Theme watching should be centralized

Yes: a `ThemeService` is the correct abstraction.

It should:

* run one watcher
* call `sync_gpui_component_theme(cx)` once per change
* bump a revision counter
* broadcast a notification to all registered windows (and/or a subscription stream)

Do not have every window spawn its own watcher.

---

## 4) Simplification Opportunities

### A. Stop storing “window handle singletons” in each module

Use `WindowRegistry`. Keep *window-specific state* (like AI focus flag, pending commands) local, but handles shouldn’t be.

---

### B. Remove the “entity holder to focus input after open”

Both Notes and AI create:

```rust
Arc<Mutex<Option<Entity<...>>>> 
```

just to focus once after window creation.

Simpler pattern:

* store `needs_initial_focus: bool` in the view
* set it `true` in `new()`
* in `render()`, if flag set, focus input and clear flag

That removes the temporary Arc/Mutex and keeps logic inside the view where it belongs.

---

### C. Don’t try to solve theme cache updates with entity references

You already learned global entity refs can leak. Don’t reintroduce that.

Use a **theme revision** mechanism instead:

* ThemeService increments revision on changes
* views check revision in render and update cached values

No entity plumbing required.

---

### D. Collapse all the “open/close/toggle” flows into 2–3 primitives

You can build all behavior from:

* `get_valid_handle(role)`
* `open_window(role, options, build)`
* `close_window(role, pre_close_hook)`

Notes toggle is just “close if open else open”. AI is “activate if open else open”.

---

## 5) Specific Recommendations (Concrete Changes + Examples)

### 5.1 Expand `WindowRegistry` into a validity-aware API

Add these functions to `src/windows/registry.rs`:

```rust
use gpui::{App, WindowHandle};
use gpui_component::Root;

pub fn get_valid_window(role: WindowRole, cx: &mut App) -> Option<WindowHandle<Root>> {
    let handle = get_window(role)?;
    let ok = handle.update(cx, |_root, _window, _cx| {}).is_ok();
    if ok { Some(handle) } else { clear_window(role); None }
}

/// Remove and return the handle (used for close paths)
pub fn take_window(role: WindowRole) -> Option<WindowHandle<Root>> {
    registry()
        .lock()
        .ok()
        .and_then(|mut reg| reg.handles.remove(&role))
}

/// Convenience: update a window if it exists and is valid
pub fn with_window<R>(
    role: WindowRole,
    cx: &mut App,
    f: impl FnOnce(&mut Root, &mut gpui::Window, &mut App) -> R,
) -> Option<R> {
    let handle = get_valid_window(role, cx)?;
    handle.update(cx, f).ok()
}
```

This kills most per-window lock gymnastics and makes “is open” meaningful.

---

### 5.2 Unify close logic and always save bounds

A close helper that also saves bounds:

```rust
pub fn close_window_with_bounds(
    role: WindowRole,
    cx: &mut gpui::App,
    persist_role: crate::window_state::WindowRole,
) {
    let Some(handle) = take_window(role) else { return; };

    let _ = handle.update(cx, |_, window, _| {
        let wb = window.window_bounds();
        crate::window_state::save_window_from_gpui(persist_role, wb);
        window.remove_window();
    });
}
```

Then Notes/AI close functions become one-liners.

**Important:** this still doesn’t solve traffic-light close. For that, add one of these:

#### Option A (best): hook a window close event (if GPUI provides it)

Pseudo:

```rust
window.on_close(cx.listener(move |_, window, cx| {
    crate::window_state::save_window_from_gpui(persist_role, window.window_bounds());
    crate::windows::clear_window(role);
}));
```

#### Option B (works without any special API): persist bounds when they change

Store bounds in the view and debounce saves (this is concrete and doesn’t rely on unknown GPUI hooks):

```rust
pub struct NotesApp {
    // ...
    last_persisted_bounds: Option<gpui::WindowBounds>,
    last_bounds_save: std::time::Instant,
}

fn maybe_persist_bounds(&mut self, window: &gpui::Window) {
    let wb = window.window_bounds();
    if self.last_persisted_bounds.as_ref() != Some(&wb)
        && self.last_bounds_save.elapsed() > std::time::Duration::from_millis(250)
    {
        self.last_persisted_bounds = Some(wb);
        self.last_bounds_save = std::time::Instant::now();
        crate::window_state::save_window_from_gpui(crate::window_state::WindowRole::Notes, wb);
    }
}
```

Call `maybe_persist_bounds(window)` inside `render()` for Notes/AI. This makes bounds persistence reliable regardless of close method.

---

### 5.3 Replace per-window theme watchers with a single `ThemeService`

Create `src/theme/service.rs` (or similar) that runs once:

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::OnceLock;

static THEME_REVISION: AtomicU64 = AtomicU64::new(1);
static THEME_SERVICE_STARTED: OnceLock<()> = OnceLock::new();

pub fn theme_revision() -> u64 {
    THEME_REVISION.load(Ordering::Relaxed)
}

fn bump_theme_revision() {
    THEME_REVISION.fetch_add(1, Ordering::SeqCst);
}

pub fn ensure_theme_service_running(cx: &mut gpui::App) {
    if THEME_SERVICE_STARTED.set(()).is_err() {
        return; // already started
    }

    cx.spawn(|cx: &mut gpui::AsyncApp| async move {
        let (mut watcher, rx) = crate::watcher::ThemeWatcher::new();
        if watcher.start().is_err() {
            return;
        }

        loop {
            gpui::Timer::after(std::time::Duration::from_millis(200)).await;
            if rx.try_recv().is_ok() {
                let _ = cx.update(|cx| {
                    crate::theme::sync_gpui_component_theme(cx);
                    bump_theme_revision();
                    crate::windows::notify_all_windows(cx);
                });
            }
        }
    }).detach();
}
```

Then delete Notes/AI watcher spawning completely. Call `ensure_theme_service_running(cx)` once from app init.

---

### 5.4 Make cached theme-dependent values self-heal via theme revision

In both `AiApp` and `NotesApp`, add:

```rust
theme_rev_seen: u64,
```

Initialize in `new()`:

```rust
let theme_rev_seen = crate::theme::service::theme_revision();
```

Then in `render()`:

```rust
let current_rev = crate::theme::service::theme_revision();
if self.theme_rev_seen != current_rev {
    self.theme_rev_seen = current_rev;
    self.cached_box_shadows = Self::compute_box_shadows();
    // any other cached theme-derived values
}
```

This fixes the “stale shadows after theme reload” bug without storing entities globally.

---

### 5.5 Delete duplicated vibrancy helpers and import from `ui_foundation`

In both windows, remove local `hex_to_rgba_with_opacity` and do:

```rust
use crate::ui_foundation::hex_to_rgba_with_opacity;
```

Then:

```rust
let bg = rgba(hex_to_rgba_with_opacity(bg_hex, opacity.main));
```

Also consider making a shared helper that returns a small palette computed from one theme load:

```rust
struct VibrancyPalette {
    bg_main: gpui::Rgba,
    bg_title: gpui::Rgba,
}

impl VibrancyPalette {
    fn from_theme(theme: &crate::theme::Theme) -> Self {
        let o = theme.get_opacity();
        Self {
            bg_main: gpui::rgba(hex_to_rgba_with_opacity(theme.colors.background.main, o.main)),
            bg_title: gpui::rgba(hex_to_rgba_with_opacity(theme.colors.background.title_bar, o.title_bar)),
        }
    }
}
```

Compute once per render and pass around.

---

### 5.6 Fix AI streaming performance (stop cloning the entire buffer)

Minimal delta approach (keeps your architecture):

* track `last_len` in poll loop
* only append new bytes

Conceptually:

```rust
let mut last_len = 0usize;
loop {
    Timer::after(Duration::from_millis(50)).await;

    let new_chunk = {
        let content = content_for_poll.lock().ok()?;
        if content.len() <= last_len { None }
        else {
            let delta = content[last_len..].to_string();
            last_len = content.len();
            Some(delta)
        }
    };

    if let Some(delta) = new_chunk {
        cx.update(|cx| {
            this.update(cx, |app, cx| {
                if app.streaming_generation != generation || app.streaming_chat_id != Some(chat_id) {
                    return;
                }
                app.streaming_content.push_str(&delta);
                app.messages_scroll_handle.scroll_to_bottom();
                cx.notify();
            });
        });
    }

    // done handling...
}
```

This removes the repeated full-string clone. (You’ll need to decide whether you’re OK slicing by byte index; for UTF-8 correctness, you can do chunking at provider boundary instead.)

---

### 5.7 Answering your Key Questions directly

1. **Should `WindowRegistry` be a global singleton managing all handles?**
   Yes. Handles should have exactly one owner. Per-window statics are duplicated sources of truth.

2. **SecondaryWindowBuilder vs factory function?**
   Start with a small “spec struct + one helper” (or a couple helpers: `open_window`, `activate_window`, `close_window`). Don’t build a whole framework yet.

3. **Should vibrancy helpers live in `ui_foundation.rs`?**
   Yes. `hex_to_rgba_with_opacity()` should exist once. Import it everywhere.

4. **Can `compute_box_shadows()` become a method on `Theme`?**
   Yes *if* you’re fine with `Theme` depending on GPUI types. If not, put it in a `theme::ui` module. Either way: one canonical implementation.

5. **Should theme watching be centralized in a `ThemeService`?**
   Yes. One watcher, one sync, one broadcast, and use a theme revision to update caches safely.

---

If you want the fastest path with minimal churn:
**(1)** add `ThemeService + theme_revision`, **(2)** update cached shadows on revision, **(3)** move vibrancy helper to `ui_foundation`, **(4)** replace window statics with registry + `get_valid_window/take_window`, **(5)** fix bounds persistence on all close paths.
