Below is an opinionated, code-level review focused on your **multi-window coordination** concerns, plus the “gotchas” I see in the provided files. I’m going to be blunt because a couple of these patterns will bite you over time (especially with theme hot reload + window reopen cycles).

---

## 1) Critical issues

### 1.1 AI window leaks the entire `AiApp` (and can make `is_ai_window_open()` lie)

In `src/ai/window.rs` you keep a **strong** `Entity<AiApp>` globally:

```rust
static AI_APP_ENTITY: OnceLock<Mutex<Option<Entity<AiApp>>>> = OnceLock::new();
```

…and you also spawn a theme watcher task that captures `ai_app_for_theme: Entity<AiApp>`:

```rust
let ai_app_for_theme = ai_app.clone();
cx.spawn(async move |cx| {
   ...
   ai_app_for_theme.update(cx, |_app, cx| { cx.notify(); });
})
```

That combination is a classic “window never truly dies” problem:

* `Entity<T>` is almost certainly reference-counted (strong).
* If *anything* holds a strong clone, your `Drop for AiApp` may never run.
* If `Drop` doesn’t run, your “clear AI_WINDOW on drop” cleanup may never happen.
* Even if the window closes, you can end up with:

  * `AI_WINDOW` still containing `Some(handle)` (stale/invalid)
  * `AI_APP_ENTITY` still containing `Some(entity)`
  * theme watcher tasks that keep running forever

This is not hypothetical: your Notes window avoids this by **not** capturing the view entity in the theme watcher.

**Fix**: do not store strong `Entity<AiApp>` globally, and do not capture a strong `Entity<AiApp>` in long-lived tasks.

**Best fix**:

* store a **weak** entity (if GPUI supports `WeakEntity<T>`)
* or don’t store the entity at all: use the `WindowHandle` to execute focus logic inside the window update closure.

---

### 1.2 Deadlock risk: calling `handle.update()` while holding the global window mutex

You do this pattern repeatedly:

```rust
let mut guard = window_handle.lock().unwrap();
if let Some(handle) = guard.take() {
    let _ = handle.update(cx, |_, window, _| {
        window.remove_window();
    });
}
```

and similarly in Notes toggle-close.

If `window.remove_window()` causes the view to drop *synchronously* (or causes any callback that tries to lock the same mutex), you can deadlock. Even if GPUI currently defers destruction, you’re relying on an implementation detail.

**Fix**: take the handle out of the mutex, drop the lock, then call `update()`.

---

### 1.3 Theme watchers are inconsistent and will multiply (AI) or are polling-heavy (both)

Notes has a singleton watcher guard (`NOTES_THEME_WATCHER_RUNNING`). AI does not.

So reopening AI can spawn multiple infinite loops. Even if you fix the entity leak, you’ll still end up with multiple watchers and redundant work.

Separately, both watchers poll every 200ms. That’s probably fine for one watcher, but not if you scale to multiple windows + tray + other features.

**Fix**: run **one** theme watcher for the entire app and fan out notifications.

---

### 1.4 Window discovery by size/title is fragile (and your `WindowManager` encourages unsafe use)

Your `WindowManager` exists because `NSApp.windows` includes lots of system/tray windows. Correct problem.

But the solution in `find_and_register_main_window()` is still brittle:

* Matching by size can misidentify windows (especially if you add a settings window, a preview window, or if the main window bounds change).
* Storing raw `NSWindow` pointers as `Send + Sync` is risky (even if “reading properties works”, it’s still a footgun).

**Fix**:

* Prefer “register at creation time” (your own handle/role registry).
* If you must discover via NSApp, tag your NSWindow using a non-user-facing identifier (not title, not size).

---

### 1.5 Theme-dependent caches don’t update

Both `AiApp` and `NotesApp` cache `cached_box_shadows` computed from `crate::theme::load_theme()`, but your theme reload handlers only do:

```rust
crate::theme::sync_gpui_component_theme(cx);
cx.notify();
```

They never call `update_theme()` to recompute shadows. So drop shadow changes won’t apply until restart.

**Fix**: on theme change, call `app.update_theme(cx)` (or just recompute lazily on render if cheap).

---

## 2) Performance concerns

### 2.1 Streaming UI update is O(n²) due to repeated full-string clones

AI streaming loop does this every ~50ms:

* lock shared buffer
* clone whole string
* write whole string into app state
* re-render

For long responses, this becomes “copy the entire response 20 times per second”. That can absolutely cause stutter.

**Fix options**:

* store only appended delta and append in UI state
* or store a rope / `String` plus “last_len” and only clone the delta
* or send chunks over a channel to the UI thread and append without cloning the entire buffer repeatedly

### 2.2 Theme watcher polling in each window

Even if it’s “only” 200ms polling, doing it per-window is wasted CPU wakeups. You want one watcher → broadcast.

### 2.3 Notes: lots of `Arc<Mutex<...>>` “pending actions” plumbing

It works, but it’s heavy and makes reasoning about focus and state harder. This is a good candidate for a GPUI-native event/message approach (or a single local queue) once you have a cross-window bus.

---

## 3) API design feedback

### 3.1 `OnceLock<Mutex<Option<WindowHandle>>>` is acceptable, but you’re using it in the most error-prone way

Your pattern is “okay” for single-instance windows **if**:

* you never hold the lock while calling into GPUI (`handle.update`)
* you never keep strong references that prevent `Drop` cleanup
* you treat the stored handle as “maybe stale” and validate when needed

Right now you violate the first two in the AI window.

### 3.2 Three separate globals is duplicated policy and will drift

You’ve already got:

* AI_WINDOW
* NOTES_WINDOW
* (implied main window solution + `WindowManager`)

This becomes “three implementations of the same lifecycle logic” (open, focus, validate, close, cleanup). Bugs will diverge.

**Better**: one registry keyed by role:

```rust
enum WindowRole { Main, Notes, AiChat /* ... */ }
```

that stores:

* `WindowHandle<Root>` (GPUI-level)
* optionally platform-native `NSWindow id` (macOS-only)
* optionally a per-window “focus hook” (how to focus primary input)

### 3.3 Theme should be global state

You’re already syncing `gpui-component` theme globally (`sync_gpui_component_theme(cx)`), so treating theme as “per-window watcher” is strictly worse.

Other multi-window apps generally do:

* one theme source of truth (global)
* views subscribe / re-render when theme revision changes

---

## 4) Simplification opportunities

### 4.1 Replace per-window theme watchers with a `ThemeService`

One watcher.
One place to call `sync_gpui_component_theme(cx)`.
One place to notify all windows.

### 4.2 Make window creation impossible to forget the `Root` wrapper

This is a perfect “helper function” problem. Don’t rely on developer memory.

### 4.3 Stop “discovering windows” after the fact

Register your window handles when you create them. Only fall back to scanning when you truly must (e.g., external windows not created by your code).

### 4.4 Unify open/focus/close logic

Notes and AI are already very similar but implemented differently. That’s a smell.

---

## 5) Specific recommendations with concrete code

### 5.1 Fix the “lock held during update” pattern (AI + Notes)

**Before (current):**

```rust
pub fn close_ai_window(cx: &mut App) {
    let window_handle = AI_WINDOW.get_or_init(|| std::sync::Mutex::new(None));
    let mut guard = window_handle.lock().unwrap();

    if let Some(handle) = guard.take() {
        let _ = handle.update(cx, |_, window, _| {
            window.remove_window();
        });
    }
}
```

**After (release lock before update):**

```rust
pub fn close_ai_window(cx: &mut App) {
    let handle = {
        let slot = AI_WINDOW.get_or_init(|| std::sync::Mutex::new(None));
        slot.lock().ok().and_then(|mut g| g.take())
    };

    if let Some(handle) = handle {
        let _ = handle.update(cx, |_, window, _| {
            window.remove_window();
        });
    }

    // Clear any other references here (see next sections)
}
```

Do the same for Notes toggle-close (`open_notes_window`’s “toggle OFF” path) and `close_notes_window()`.

---

### 5.2 Remove the strong global `AI_APP_ENTITY` (or make it weak)

Right now `AI_APP_ENTITY` is a memory-lifetime trap.

#### Option A (preferred): store `WeakEntity<AiApp>` (if GPUI supports it)

Sketch:

```rust
static AI_APP_ENTITY: OnceLock<std::sync::Mutex<Option<gpui::WeakEntity<AiApp>>>> =
    OnceLock::new();
```

When creating:

```rust
let view = cx.new(|cx| AiApp::new(window, cx));
*AI_APP_ENTITY.get_or_init(|| Mutex::new(None)).lock().unwrap() = Some(view.downgrade());
cx.new(|cx| Root::new(view, window, cx))
```

When focusing:

```rust
if let Some(weak) = AI_APP_ENTITY.get().and_then(|m| m.lock().ok()?.clone()) {
    if let Some(ai_app) = weak.upgrade(cx) {
        let _ = handle.update(cx, |_root, window, cx| {
            ai_app.update(cx, |app, cx| app.focus_input(window, cx));
        });
    }
}
```

If GPUI doesn’t have `WeakEntity`, you can simulate “weak-ish” by *not storing the entity at all* and using one of the next options.

#### Option B: don’t store entity; focus via a “focus request” mechanism inside the window

A practical pattern:

* `AiApp` stores `needs_focus_input: bool`
* `open_ai_window()` sets it true via `handle.update(...)`
* `AiApp::render()` or a small “on_mount” task checks it and calls focus once

Example:

```rust
pub struct AiApp {
    ...
    needs_focus_input: bool,
}

pub fn open_ai_window(cx: &mut App) -> Result<()> {
    ...
    if let Some(handle) = existing {
        cx.activate(true);
        let _ = handle.update(cx, |_root, window, cx| {
            // Activate window and ask the view to focus itself
            window.activate_window();
            // If Root lets you access inner view, set a flag here.
        });
        return Ok(());
    }
    ...
}
```

This depends on whether `Root` exposes inner view access; if it doesn’t, add your own wrapper instead of `gpui_component::Root` (or contribute a helper API upstream).

---

### 5.3 Make AI theme watcher a singleton and stop capturing `Entity<AiApp>`

Copy the Notes approach and notify via window handle only. Example:

```rust
static AI_THEME_WATCHER_RUNNING: std::sync::atomic::AtomicBool =
    std::sync::atomic::AtomicBool::new(false);

fn ensure_ai_theme_watcher(cx: &mut App) {
    if AI_THEME_WATCHER_RUNNING.swap(true, std::sync::atomic::Ordering::SeqCst) {
        return;
    }

    cx.spawn(async move |cx: &mut gpui::AsyncApp| {
        let (mut theme_watcher, theme_rx) = ThemeWatcher::new();
        if theme_watcher.start().is_err() {
            AI_THEME_WATCHER_RUNNING.store(false, std::sync::atomic::Ordering::SeqCst);
            return;
        }

        loop {
            gpui::Timer::after(std::time::Duration::from_millis(200)).await;

            if theme_rx.try_recv().is_ok() {
                let update_result = cx.update(|cx| {
                    crate::theme::sync_gpui_component_theme(cx);

                    // Notify AI window if open
                    let slot = AI_WINDOW.get_or_init(|| std::sync::Mutex::new(None));
                    if let Ok(guard) = slot.lock() {
                        if let Some(ref handle) = *guard {
                            let _ = handle.update(cx, |_root, _window, cx| {
                                cx.notify();
                            });
                        }
                    }
                });

                if update_result.is_err() {
                    break;
                }
            }
        }

        AI_THEME_WATCHER_RUNNING.store(false, std::sync::atomic::Ordering::SeqCst);
    })
    .detach();
}
```

Then in `open_ai_window`, call `ensure_ai_theme_watcher(cx);`

But…

---

### 5.4 Better: one global `ThemeService` for all windows (AI + Notes + Main + Tray)

This is what you actually want.

Create `src/theme/service.rs`:

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use gpui::{App, AsyncApp, Timer};

static THEME_SERVICE_RUNNING: AtomicBool = AtomicBool::new(false);

pub fn ensure_theme_service(cx: &mut App) {
    if THEME_SERVICE_RUNNING.swap(true, Ordering::SeqCst) {
        return;
    }

    cx.spawn(async move |cx: &mut AsyncApp| {
        let (mut watcher, rx) = crate::watcher::ThemeWatcher::new();
        if watcher.start().is_err() {
            THEME_SERVICE_RUNNING.store(false, Ordering::SeqCst);
            return;
        }

        loop {
            Timer::after(std::time::Duration::from_millis(200)).await;

            if rx.try_recv().is_ok() {
                let result = cx.update(|cx| {
                    crate::theme::sync_gpui_component_theme(cx);

                    // Notify all known windows (see registry below)
                    crate::windows::notify_all_windows(cx);
                });

                if result.is_err() {
                    break;
                }
            }
        }

        THEME_SERVICE_RUNNING.store(false, Ordering::SeqCst);
    })
    .detach();
}
```

Then call `ensure_theme_service(cx)` once early (app startup), or lazily before opening any window.

This eliminates duplicated watchers and guarantees theme sync across all windows (and you can also update tray UI there).

---

### 5.5 Replace 3 separate `OnceLock`s with a single registry keyed by role

New file `src/windows/registry.rs`:

```rust
use std::collections::HashMap;
use std::sync::{Mutex, OnceLock};

use gpui::{App, WindowHandle};
use gpui_component::Root;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum WindowRole {
    Main,
    Notes,
    AiChat,
}

struct WindowRegistry {
    handles: HashMap<WindowRole, WindowHandle<Root>>,
}

static REGISTRY: OnceLock<Mutex<WindowRegistry>> = OnceLock::new();

fn registry() -> &'static Mutex<WindowRegistry> {
    REGISTRY.get_or_init(|| Mutex::new(WindowRegistry { handles: HashMap::new() }))
}

pub fn get(role: WindowRole) -> Option<WindowHandle<Root>> {
    registry().lock().ok()?.handles.get(&role).cloned()
}

pub fn set(role: WindowRole, handle: WindowHandle<Root>) {
    if let Ok(mut reg) = registry().lock() {
        reg.handles.insert(role, handle);
    }
}

pub fn clear(role: WindowRole) {
    if let Ok(mut reg) = registry().lock() {
        reg.handles.remove(&role);
    }
}

pub fn notify_all_windows(cx: &mut App) {
    let handles: Vec<WindowHandle<Root>> = registry()
        .lock()
        .ok()
        .map(|reg| reg.handles.values().cloned().collect())
        .unwrap_or_default();

    for handle in handles {
        let _ = handle.update(cx, |_root, _window, cx| {
            cx.notify();
        });
    }
}
```

Then Notes and AI modules stop owning their own statics and just use this registry.

That also makes `is_*_window_open` consistent.

---

### 5.6 Enforce `Root` wrapper via a window-opening helper

New helper:

```rust
use anyhow::Result;
use gpui::{App, Window, WindowHandle, WindowOptions};
use gpui_component::Root;

pub fn open_root_window<T: gpui::Render + 'static>(
    cx: &mut App,
    options: WindowOptions,
    build: impl FnOnce(&mut Window, &mut gpui::Context<T>) -> T + 'static,
) -> Result<WindowHandle<Root>> {
    // Ensure gpui-component is initialized once somewhere central
    // and theme service is running
    crate::theme::service::ensure_theme_service(cx);

    cx.open_window(options, move |window, cx| {
        let view = cx.new(|cx| build(window, cx));
        cx.new(|cx| Root::new(view, window, cx))
    })
}
```

Then opening windows becomes impossible to mess up:

```rust
let handle = crate::windows::open_root_window(cx, window_options, |window, cx| {
    AiApp::new(window, cx)
})?;
```

---

### 5.7 Stop “discovering your own windows” by index/size; tag them

If you must locate NSWindows later (for `setLevel`, `setCollectionBehavior`, etc.), don’t use the array index or size.

Use an identifier tag.

On macOS, `NSWindow.identifier` is meant for this kind of thing. Pattern:

* after creating the window, set a stable identifier:

  * `"com.scriptkit.window.notes"`
  * `"com.scriptkit.window.ai"`
* later, iterate `NSApp.windows` and match identifier

This avoids title collisions and “window title changes”.

Even better: register the native pointer at creation time (if GPUI exposes it). If GPUI doesn’t, identifier tagging is the next best approach.

---

### 5.8 Cross-window communication in GPUI: keep it boring

You don’t need anything fancy.

**Pattern A (direct, targeted):**

* window registry stores `WindowHandle<Root>`
* to talk to a window: `handle.update(cx, |root, window, cx| { ... })`

This is the simplest and the most predictable.

**Pattern B (broadcast, decoupled):**

* a global `UiBus` (single producer/multiple consumer)
* windows subscribe and react

But be careful: a bus that causes all windows to re-render on every message can hurt the “launcher appears instantly / 60fps scroll” constraint. Use direct targeted updates wherever possible.

For theme specifically, broadcast is fine.

---

## Direct answers to your expert questions

### Q1) Is `OnceLock<Mutex<Option<WindowHandle>>>` the right pattern?

It’s *acceptable* for “single-instance per process”, but your current implementation has sharp edges:

* don’t hold the lock while calling `handle.update()`
* don’t store strong `Entity<T>` globally alongside it
* treat `Option<WindowHandle>` as “maybe stale”; validate on use

If you keep the pattern, wrap it in a reusable abstraction so every window follows the same lifecycle rules.

### Q2) How should we discover our own windows reliably on macOS?

Don’t “discover” if you can “register”.

* Best: register the `WindowHandle` (and native NSWindow id if needed) at creation time.
* If you must search `NSApp.windows`, use a stable identifier tag, not index and not size.

Window titles are user-facing; they’re not a reliable machine identifier.

### Q3) Should theme be global or per-window?

Global. One watcher. One source of truth. Broadcast a “theme revision changed” signal or just notify all windows.

Per-window watchers are wasted work and introduce drift (as you already see with AI vs Notes behavior).

### Q4) Better abstraction than 3 separate `OnceLock`s?

Yes: one `WindowRegistry<HashMap<WindowRole, WindowHandle<Root>>>` (plus small helper functions), or a reusable `SingletonWindow` type.

### Q5) Patterns for cross-window communication in GPUI?

Use the thing you already have: `WindowHandle::update` as a “call into that window on the UI thread”.

Add a registry and you’ve got a clean, explicit cross-window API. Only introduce a bus when you truly need broadcast.

---

## The “minimum viable refactor” I’d do first (in order)

1. **Stop holding global locks while calling `handle.update()`** (AI + Notes).
2. **Remove/replace `AI_APP_ENTITY` strong global reference** (this is the biggest correctness issue).
3. **Make theme watching singleton** (ideally one ThemeService for the whole app).
4. **Introduce `WindowRole` + a single registry** to replace separate statics and window discovery hacks.
5. **Add `open_root_window()` helper** so `Root` is never forgotten again.

If you do just those five, your multi-window architecture becomes a lot more robust without slowing anything down.
