## 1) Critical issues

### A. Actions popup keys can “leak” to the underlying prompt

In `render_prompts/div.rs`, the actions-popup branch doesn’t **return** and (more importantly) doesn’t **stop propagation**. If GPUI bubbles key events (very likely, given your wrapper/child setup), then while the actions popup is open:

* `up/down` can move the actions selection **and** also scroll/navigate inside the underlying `DivPrompt`.
* character keys can filter actions **and** type into the underlying prompt.

That’s the kind of bug that only shows up once you have real interactive Div prompts (editors, textfields, web-ish content).

**Fix:** when the actions dialog consumes a key, always stop propagation (if GPUI supports it) and return. Don’t rely on “early return from the closure” alone.

---

### B. Shortcut precedence is inconsistent (and likely wrong) when actions popup is open

In `render_script_list.rs`, you check `action_shortcuts` **before** routing to the actions popup:

```rust
// script_list
if !this.action_shortcuts.is_empty() { ... return; }
...
if this.show_actions_popup { ... return; }
```

In `render_prompts/arg.rs`, you check action shortcuts **after** the popup routing (and only when popup is not open).

This difference matters:

* With the current `script_list` ordering, a script-defined shortcut like `"k"` (or anything without modifiers) can fire while the user is typing into the actions search box. That’s a nasty UX footgun.
* It also means your “actions popup is modal” assumption is violated in one view but not the others.

**Fix:** when the actions popup is open, route to it first (after truly-global shortcuts like Cmd+W), and do not run normal shortcut dispatch unless you explicitly want that.

---

### C. Escape handling may dismiss the whole prompt instead of closing the actions popup

In `render_prompts/arg.rs` and `render_prompts/div.rs` you call:

```rust
if this.handle_global_shortcut_with_options(event, true, cx) {
    return;
}
```

before actions-popup routing.

If `handle_global_shortcut_with_options(..., true, ...)` handles `escape` to dismiss prompts, then **Escape will never reach the actions popup**, and users will dismiss the entire prompt instead of closing the popup.

Maybe your global handler already checks `show_actions_popup` internally—maybe. But from the call sites alone, this is risky and easy to regress.

**Fix:** make the “Escape semantics” decision in the view layer (or in the shared router), not in a generic global handler that runs before modal routing.

---

### D. Missing `cx.notify()` on some close paths (possible “popup doesn’t disappear” glitches)

In `render_prompts/arg.rs`, on Enter you close the popup but don’t `cx.notify()`:

```rust
if should_close {
    this.show_actions_popup = false;
    this.actions_dialog = None;
    this.focused_input = FocusedInput::ArgPrompt;
    window.focus(&this.focus_handle, cx);
}
// no cx.notify()
this.trigger_action_by_name(&action_id, cx);
return;
```

If `trigger_action_by_name` doesn’t always notify, the UI can lag a frame or stay stale.

Same pattern exists in `render_prompts/div.rs` (close on Enter without notify).

**Fix:** standardize “closing popup always notifies” inside a shared close helper.

---

### E. Async updates to the separate actions window can race with close

In `render_script_list.rs`, every up/down and every search edit spawns a detached task that updates or resizes the actions window.

If the popup closes quickly, you can easily end up with:

* a resize task running after close
* a notify task running after close

If `resize_actions_window` / `notify_actions_window` assume the window exists, you’ve got a crash risk.

**Fix:** guard in the window ops (`if actions window exists { ... }`) and/or coalesce updates so you don’t have a queue of detached tasks.

---

## 2) Performance concerns

### A. `to_lowercase()` allocations on every keystroke

You do `event.keystroke.key.to_lowercase()` in hot paths (main launcher typing, arg prompt typing). That’s an allocation per keypress plus Unicode-lowercasing (overkill for key names).

**Fix options (in order of practicality):**

1. Use `eq_ignore_ascii_case` for comparisons like up/down/enter/escape. (No allocation.)
2. Use `to_ascii_lowercase()` instead of `to_lowercase()` when you truly need a normalized string. (Still allocates, but cheaper.)
3. Best: stop depending on lowercased strings for special keys at all—use helpers that recognize variants.

---

### B. Detached `cx.spawn(...).detach()` per keypress for actions window updates

Typing in actions search can easily generate dozens of spawns per second. That’s avoidable overhead and can create UI jitter.

**Fix:** coalesce updates:

* set a “needs_resize” flag
* schedule one flush task per frame/tick (similar to your nav coalescer approach)

---

### C. Logging per keystroke in ArgPrompt

This line runs for every keypress:

```rust
logging::log("KEY", &format!("ArgPrompt key: '{}' cmd={}", key_str, has_cmd));
```

If logging is not aggressively gated, this is real overhead (format allocs + storage).

**Fix:** gate behind debug level / feature flag, or remove once stable.

---

## 3) API design feedback (and direct answers to your key questions)

### 1. `route_key_to_actions_dialog()` as method or standalone?

Make it a **`ScriptListApp` method**.

It needs to touch:

* `self.show_actions_popup`
* `self.actions_dialog`
* focus restoration (`focused_input` / `focus_main_filter`)
* in script list: separate actions window notify/resize/close hooks

A standalone function will either:

* take a huge parameter list, or
* become “implicitly global” via globals, which is worse.

**Do** keep pure key-normalization in a standalone `keys` module.

---

### 2. Is `KeyEventContext` useful?

Yes, **if** it stays small and avoids allocations.

A good “context” here is basically:

* `key: &str`
* `key_char: Option<char>`
* `mods: &Modifiers`
* convenience methods (`cmd()`, `shift()`, `printable_char()`, `is_up()`…)

Don’t make it manage “consumed state” itself. Consumption should be expressed by the router’s return value + `event.stop_propagation()` at the call site.

---

### 3. Should you create a `KeyRouter` trait?

Not yet.

A trait sounds nice, but in Rust + GPUI it tends to balloon:

* lifetimes around `&mut Window` and `&mut Context<Self>`
* generics that make call sites uglier
* you still need “modal routing first” logic somewhere central

Start with one shared router method + a tiny `keys` module. Add a trait later only if you truly need polymorphic routing across many entity types.

---

### 4. Prompt-specific bindings after actions dialog routing

The rule should be:

1. Always-allowed global shortcuts (e.g. Cmd+W)
2. Toggle shortcut (Cmd+K)
3. **If actions popup open: route everything to it and consume**
4. Prompt-specific navigation and input
5. Everything else

That ensures the popup is modal and prevents key leakage.

---

### 5. Return `bool` or use `event.stop_propagation()`?

Use **both**, in the right places:

* Router returns `bool` or an enum outcome (`Handled`, `Execute(...)`)
* The handler calls `event.stop_propagation()` when handled (if GPUI supports it)

This gives you clean internal control flow *and* correct event bubbling behavior.

---

## 4) Simplification opportunities

### A. Remove the “bool + Option” double state (optional but recommended)

Right now you have:

* `show_actions_popup: bool`
* `actions_dialog: Option<Entity<...>>`

That’s a classic drift hazard.

A cleaner approach:

```rust
enum ActionsPopupState {
    Closed,
    Open {
        dialog: Entity<ActionsDialog>,
        host: ActionsDialogHost,
    },
}
```

If you truly need “show search box even while dialog is not ready”, add an `Opening` variant explicitly.

Even if you don’t do this now, at least enforce invariants with a debug assert.

---

### B. Centralize close behavior

Closing logic is duplicated and slightly different everywhere (focus restoration, notify calls, window close).

Make one helper:

* `close_actions_popup(host, window, cx)`

and call it from the router. This is where you standardize `cx.notify()`.

---

## 5) Specific recommendations with concrete code

### Step 1: Add `src/ui/keys.rs` (allocation-free normalization)

```rust
// src/ui/keys.rs
use gpui::KeyDownEvent;

pub fn is_up(key: &str) -> bool {
    key.eq_ignore_ascii_case("up") || key.eq_ignore_ascii_case("arrowup")
}

pub fn is_down(key: &str) -> bool {
    key.eq_ignore_ascii_case("down") || key.eq_ignore_ascii_case("arrowdown")
}

pub fn is_enter(key: &str) -> bool {
    key.eq_ignore_ascii_case("enter") || key.eq_ignore_ascii_case("return")
}

pub fn is_escape(key: &str) -> bool {
    key.eq_ignore_ascii_case("escape") || key.eq_ignore_ascii_case("esc")
}

pub fn is_backspace(key: &str) -> bool {
    key.eq_ignore_ascii_case("backspace")
        || key.eq_ignore_ascii_case("delete") // optional, decide if you want this
}

pub fn printable_char(event: &KeyDownEvent) -> Option<char> {
    event
        .keystroke
        .key_char
        .as_ref()
        .and_then(|s| s.chars().next())
        .filter(|ch| !ch.is_control())
}
```

Now replace every `"up" | "arrowup"` with `keys::is_up(key)` etc.

---

### Step 2: Add a host enum + router outcome

```rust
#[derive(Clone, Copy)]
pub enum ActionsDialogHost {
    /// Separate popup window (script list behavior)
    MainList,
    /// Inline overlay inside the same window (prompt behavior)
    Inline { restore_focus: FocusedInput },
}

pub enum ActionsRoute {
    NotHandled,
    Handled,
    Execute { action_id: String },
}
```

---

### Step 3: Implement the shared router on `ScriptListApp`

```rust
impl ScriptListApp {
    pub fn route_key_to_actions_dialog(
        &mut self,
        event: &gpui::KeyDownEvent,
        window: &mut Window,
        cx: &mut Context<Self>,
        host: ActionsDialogHost,
    ) -> ActionsRoute {
        if !self.show_actions_popup {
            return ActionsRoute::NotHandled;
        }

        let Some(dialog) = self.actions_dialog.clone() else {
            // Defensive: if UI says it's open, don't leak keys.
            return ActionsRoute::Handled;
        };

        let key = event.keystroke.key.as_str();

        if crate::ui::keys::is_up(key) {
            dialog.update(cx, |d, cx| d.move_up(cx));
            self.actions_dialog_after_update(cx, host, ActionsDialogUpdate::Moved, dialog);
            return ActionsRoute::Handled;
        }

        if crate::ui::keys::is_down(key) {
            dialog.update(cx, |d, cx| d.move_down(cx));
            self.actions_dialog_after_update(cx, host, ActionsDialogUpdate::Moved, dialog);
            return ActionsRoute::Handled;
        }

        if crate::ui::keys::is_enter(key) {
            let read = dialog.read(cx);
            let action_id = read.get_selected_action_id();
            let should_close = read.selected_action_should_close();
            drop(read);

            if let Some(action_id) = action_id {
                if should_close {
                    self.close_actions_popup(window, cx, host);
                }
                return ActionsRoute::Execute { action_id };
            }
            return ActionsRoute::Handled;
        }

        if crate::ui::keys::is_escape(key) {
            self.close_actions_popup(window, cx, host);
            return ActionsRoute::Handled;
        }

        if crate::ui::keys::is_backspace(key) {
            dialog.update(cx, |d, cx| d.handle_backspace(cx));
            self.actions_dialog_after_update(cx, host, ActionsDialogUpdate::SearchChanged, dialog);
            return ActionsRoute::Handled;
        }

        if let Some(ch) = crate::ui::keys::printable_char(event) {
            dialog.update(cx, |d, cx| d.handle_char(ch, cx));
            self.actions_dialog_after_update(cx, host, ActionsDialogUpdate::SearchChanged, dialog);
            return ActionsRoute::Handled;
        }

        // Modal: swallow everything else while open
        ActionsRoute::Handled
    }

    fn close_actions_popup(
        &mut self,
        window: &mut Window,
        cx: &mut Context<Self>,
        host: ActionsDialogHost,
    ) {
        self.show_actions_popup = false;
        self.actions_dialog = None;

        match host {
            ActionsDialogHost::MainList => {
                cx.spawn(async move |_this, cx| {
                    cx.update(close_actions_window).ok();
                })
                .detach();
                self.focus_main_filter(window, cx);
            }
            ActionsDialogHost::Inline { restore_focus } => {
                self.focused_input = restore_focus;
                window.focus(&self.focus_handle, cx);
            }
        }

        cx.notify();
    }

    fn actions_dialog_after_update(
        &mut self,
        cx: &mut Context<Self>,
        host: ActionsDialogHost,
        update: ActionsDialogUpdate,
        dialog: Entity<ActionsDialog>,
    ) {
        // Only the MainList host needs separate-window work.
        if !matches!(host, ActionsDialogHost::MainList) {
            return;
        }

        match update {
            ActionsDialogUpdate::Moved => {
                cx.spawn(async move |_this, cx| {
                    cx.update(notify_actions_window).ok();
                })
                .detach();
            }
            ActionsDialogUpdate::SearchChanged => {
                cx.spawn(async move |_this, cx| {
                    cx.update(|cx| resize_actions_window(cx, &dialog)).ok();
                })
                .detach();
            }
        }
    }
}

enum ActionsDialogUpdate {
    Moved,
    SearchChanged,
}
```

This removes 80 lines x N files while still allowing host-specific behavior.

---

### Step 4: Use it in `render_script_list.rs` with correct precedence

Key changes:

* check Cmd+K toggle before routing (so Cmd+K can close too)
* route popup before action shortcuts (modal)
* stop propagation when handled

Sketch:

```rust
let handle_key = cx.listener(
    move |this: &mut Self, event: &gpui::KeyDownEvent, window: &mut Window, cx: &mut Context<Self>| {

        // 1) Always-global shortcuts first (Cmd+W etc)
        if this.handle_global_shortcut_with_options(event, false, cx) {
            event.stop_propagation(); // if available
            return;
        }

        let key = event.keystroke.key.as_str();
        let mods = &event.keystroke.modifiers;

        // 2) Cmd+K toggle (so it works both open/close)
        if mods.platform && key.eq_ignore_ascii_case("k") {
            this.toggle_actions(cx, window);
            event.stop_propagation();
            return;
        }

        // 3) Modal routing when popup open
        match this.route_key_to_actions_dialog(event, window, cx, ActionsDialogHost::MainList) {
            ActionsRoute::Execute { action_id } => {
                this.handle_action(action_id, cx);
                event.stop_propagation();
                return;
            }
            ActionsRoute::Handled => {
                event.stop_propagation();
                return;
            }
            ActionsRoute::NotHandled => {}
        }

        // 4) Now action shortcuts / other bindings (popup is closed)
        // ... existing SDK shortcut logic ...
        // ... existing Cmd+... logic ...
        // ... list nav ...
    }
);
```

If `stop_propagation()` isn’t the right API name in GPUI, adapt to whatever GPUI uses—just don’t let handled keys bubble.

---

### Step 5: Use it in `render_prompts/arg.rs` and `render_prompts/div.rs`

Same pattern, but host is inline and execution uses `trigger_action_by_name`:

```rust
match this.route_key_to_actions_dialog(
    event,
    window,
    cx,
    ActionsDialogHost::Inline { restore_focus: FocusedInput::ArgPrompt },
) {
    ActionsRoute::Execute { action_id } => {
        this.trigger_action_by_name(&action_id, cx);
        event.stop_propagation();
        return;
    }
    ActionsRoute::Handled => {
        event.stop_propagation();
        return;
    }
    ActionsRoute::NotHandled => {}
}
```

And in `div.rs` use `restore_focus: FocusedInput::None`.

This single change fixes the “key leakage” issue.

---

### Step 6: Standardize arrow matching everywhere

Replace:

```rust
match key_str.as_str() {
  "up" | "arrowup" => ...
```

with:

```rust
let key = event.keystroke.key.as_str();
if keys::is_up(key) { ... }
```

This also eliminates the `to_lowercase()` dependency in many places.

---

## Bottom line

You don’t need a trait framework here. You need:

* a tiny `keys` module (allocation-free normalization),
* a single `route_key_to_actions_dialog` method with a small `host` parameter,
* and consistent “modal consumes + stop propagation” behavior.

That will kill the duplication, prevent drift, and fix the most likely real-world bug (keys leaking into prompts while the actions popup is open).
