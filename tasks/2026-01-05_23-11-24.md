## 1) Critical issues

### A) `DesignVariant` is applied inconsistently (mixed palettes)

You’re already feeling this pain (17+ branches). In the code shown, **three prompts partially ignore `design_variant`** and still hardcode theme colors in key places:

* **`TemplatePrompt`**: preview box + field backgrounds/borders use `self.theme...` even when `design_variant != Default`.
* **`SelectPrompt`**: search box bg + focused row bg + checkbox color all use `self.theme...` regardless of `design_variant`.
* **`DropPrompt`**: drop-zone bg uses `self.theme...` regardless of `design_variant`.

That creates a “Franken-theme” where some pieces come from tokens and some from theme. It’s not just aesthetic — it guarantees you’ll keep reintroducing bugs during refactors.

**Action:** centralize all color selection behind a single resolved palette (your proposed `DesignContext` is exactly the right move, but you should enforce using it everywhere).

---

### B) `SelectPrompt` has a real contrast bug (focused + selected becomes invisible)

In `src/prompts/select.rs`:

* Focused row background: `rgb(self.theme.colors.accent.selected)`
* Selected checkbox color: `rgb(self.theme.colors.accent.selected)`

So when an item is **both focused and selected**, the checkbox icon becomes the **same color as the background** → invisible.

Also, the **text color doesn’t change when focused**, so you can easily end up with unreadable name/description on an accent background.

**Action:** derive focused/selected colors from a resolved palette and explicitly choose “text on accent” colors when background is accent.

---

### C) `SelectPrompt` description layout is likely wrong

`choice_item` is `.flex_row()` and you append the optional description as another child. That will place description **in the same row**, not under the name. This is probably not what you want.

**Action:** make the right side a column: checkbox left, (name + desc) stacked.

---

### D) Arg/Select lists are not scrollable (selection can go off-screen)

Both `ArgPrompt` and `SelectPrompt` use `overflow_y_hidden()` for the list containers and implement up/down navigation. If you have more items than fit, you can navigate to items that are clipped and never come into view.

Even if “normally small”, this is the kind of issue that shows up immediately in a launcher app.

**Action:** use `overflow_y_scroll()` (and ensure the element is stateful via `.id(...)` if GPUI requires it), plus ideally scroll-to-focused.

---

### E) `DivPrompt` re-parses HTML on every render

`parse_html(&self.html)` is called inside `render()`. That’s expensive and completely avoidable.

Even worse: scroll events can trigger redraws; if this is used in chat, you’ll pay parsing costs constantly.

**Action:** cache the parsed AST in the entity state and re-parse only when `html` changes.

---

### F) `DivPrompt` doesn’t actually render inline formatting inside paragraphs/headers

`render_element(HtmlElement::Paragraph(children))` calls `collect_text(children)` and renders a single text block. That **throws away** inline `<strong>`, `<em>`, and **clickable links** inside paragraphs (the most common place links appear).

You have a `render_inline()` implementation… but it’s unused (and it also doesn’t attach click handlers for links).

**Action:** either:

* fully commit to “flatten formatting” and delete the dead code + update docstring, **or**
* use `render_inline()` in paragraph/header rendering and make links clickable there too.

Right now it’s in a misleading middle state.

---

### G) Theme hot-reload: storing `Arc<Theme>` in each prompt is a potential trap

Your constraints say “Theme hot-reload across all windows”. With the current shape, hot reload only works if:

* theme data is **mutated behind interior mutability** (rare for a theme struct), or
* you explicitly push a new `Arc<Theme>` into every prompt entity when theme changes.

If your hot reload strategy is “replace a global `Arc<Theme>`”, then prompts holding their own cloned `Arc` will not update.

**Action:** strongly consider a shared `ThemeHandle` (watchable / observable / ArcSwap / GPUI model) instead of copying a plain `Arc<Theme>` into every prompt.

---

### H) Unstable semantic IDs during filtering

In `ArgPrompt` and `SelectPrompt`, fallback semantic IDs are generated with the **display index** (`idx` / `display_idx`). When filtering changes, display indices change → IDs change → GPUI sees different elements → you get identity churn (bad for retained state and can produce visual glitches).

**Action:** generate IDs using the **stable underlying choice index** (`choice_idx`) or a stable per-choice key.

---

## 2) Performance concerns

### A) `DivPrompt` HTML parse + flattening allocations

* `parse_html()` per render is the big one.
* `collect_text()` allocates new Strings repeatedly, recursively, and for lists it concatenates with extra spaces.

If DivPrompt is used for chat output, this will bite hard.

**Fix:** cache parsed AST; optionally cache “plain text” representation if you really want flattening.

---

### B) Filtering is O(n * alloc) per keystroke

Both `ArgPrompt::refilter()` and `SelectPrompt::refilter()` do:

```rust
choice.name.to_lowercase().contains(&filter_lower)
```

That allocates a new lowercase String for every choice, every keypress.

**Fix options:**

* Precompute `lower_name: String` once alongside choices (cheap + big win).
* Or use ASCII-only compare if names are ASCII (fast path).
* Or use a matcher crate (but that may be heavier than you want).

---

### C) `SelectPrompt` selection membership checks are O(n²) in practice

Per item render you do `self.selected.contains(&choice_idx)` (linear), and toggling uses `position()` (linear). If the list is big and selection is big, it degrades quickly.

**Fix:** `HashSet<usize>` for membership, or a `Vec<bool>` / bitset keyed by choice index.

---

### D) Lots of “small” per-render allocations that add up

* `event.keystroke.key.to_lowercase()` allocates on every keydown.
* `format!(...)` for semantic IDs each render.
* repeated `SharedString::from(...)` conversions.
* `generate_semantic_id(...)` called inside render loops.

Individually minor, but this is a launcher app where “instant” matters.

**Fix:** cache what’s stable: semantic IDs, lowercased names, constant labels, etc.

---

## 3) API design feedback

### 1) `PromptBase`: struct composition wins (with a tiny trait + macro)

A trait alone won’t remove duplicated fields; you’ll still need storage. A `PromptBase` **struct embedded in each prompt** is the right move.

What you *also* want is a tiny trait to access it (`HasPromptBase`) and a simple macro for delegation (`impl_focusable_via_base!`).

Why not “implement `Focusable` for all `T: HasPromptBase`”? Orphan rules: you can’t implement a foreign trait (`Focusable`) for a type parameter `T`. So: **macro or per-type impl**.

---

### 2) Derive macro for focus delegation: not worth it here

A proc-macro derive adds maintenance, build complexity, and slows iteration. You only have ~8 prompts. A `macro_rules!` helper is clean and keeps this refactor low-risk.

---

### 3) `DesignContext` is the correct abstraction — with one important constraint

Yes: `DesignContext` is the right way to kill variant branching. But don’t make it “optional sugar”.

Make it the *only* way UI code gets colors. Otherwise people will keep reaching for `self.theme.colors...` and you’ll keep getting mixed palettes.

I’d structure it as **resolved colors + spacing/visual tokens**:

* `spacing`, `visual` always from tokens
* `colors` are “resolved” from either `theme` or `tokens.colors()` depending on variant
* provide helpers that return `gpui::Rgba` directly

---

### 4) Generic `render_entity_prompt<T>`: use it for chrome, let complex prompts opt out

A generic wrapper is good for:

* root container chrome (vibrancy background handling, focus tracking, key_context)
* overlay layers (actions dialog)
* shared padding/margins if consistent

But **DivPrompt and EditorPrompt** will likely want to opt out or only use a subset. Don’t fight it: “one wrapper to rule them all” often creates more complexity than it removes.

A good compromise: wrapper handles “shell”, each prompt provides `render_body()`.

---

### 5) Actions dialog routing belongs in the app-level input router

If the actions dialog is global UI state, key routing should be centralized. Putting it in each prompt is exactly why you have 6 copies.

Best pattern:

* `ScriptListApp::route_key_to_actions_dialog(event, cx) -> bool` returns “consumed”
* each prompt key handler starts with:

```rust
if app.route_key_to_actions_dialog(event, cx) { return; }
```

Even better: if you have a wrapper shell for prompts, do it there and keep prompt key handlers focused on prompt logic.

---

## 4) Simplification opportunities

### A) Delete or use `render_inline()`

Right now it’s dead code and misleading. Either:

* remove it and explicitly document “DivPrompt flattens inline formatting”, or
* wire it into paragraph/header rendering and finish link click behavior.

---

### B) Remove duplicated link handling logic

`DivPrompt::handle_link_click()` duplicates the closure logic in `render()`. Keep one.

---

### C) Standardize “submit/cancel” on `PromptBase`

Most prompts implement:

```rust
fn submit_cancel(&mut self) { (self.on_submit)(self.id.clone(), None); }
```

That should be `self.base.cancel()` everywhere.

---

### D) Standardize constructors

You currently have a mix of:

* `new(...)` only
* `new(...)` + `with_design(...)`
* `with_options(...)`

Use `PromptBase::new(...)` plus prompt-specific constructors. This keeps variants consistent and reduces drift.

---

## 5) Specific recommendations with examples

### A) `PromptBase` + delegation macro (minimal, low-risk)

`src/prompts/base.rs`:

```rust
use std::sync::Arc;
use gpui::FocusHandle;

use crate::{theme, designs::DesignVariant};
use super::SubmitCallback;

pub struct PromptBase {
    pub id: String,
    pub focus_handle: FocusHandle,
    pub on_submit: SubmitCallback,
    pub theme: Arc<theme::Theme>,
    pub design_variant: DesignVariant,
}

impl PromptBase {
    pub fn new(
        id: String,
        focus_handle: FocusHandle,
        on_submit: SubmitCallback,
        theme: Arc<theme::Theme>,
    ) -> Self {
        Self {
            id,
            focus_handle,
            on_submit,
            theme,
            design_variant: DesignVariant::Default,
        }
    }

    pub fn with_design(mut self, variant: DesignVariant) -> Self {
        self.design_variant = variant;
        self
    }

    #[inline]
    pub fn submit(&self, value: Option<String>) {
        (self.on_submit)(self.id.clone(), value);
    }

    #[inline]
    pub fn cancel(&self) {
        self.submit(None);
    }
}

// Keep it dead-simple: macro_rules, not proc-macro.
#[macro_export]
macro_rules! impl_focusable_via_base {
    ($ty:ty, $field:ident) => {
        impl gpui::Focusable for $ty {
            fn focus_handle(&self, _cx: &gpui::App) -> gpui::FocusHandle {
                self.$field.focus_handle.clone()
            }
        }
    };
}
```

Then in a prompt:

```rust
pub struct DropPrompt {
    pub base: PromptBase,
    pub placeholder: Option<String>,
    // ...
}

impl_focusable_via_base!(DropPrompt, base);
```

This alone removes the 8 copies of the Focusable boilerplate and centralizes submit/cancel.

---

### B) `DesignContext`: resolve colors once, stop mixing theme/tokens

Shape it so you can’t “accidentally” use theme colors in prompt rendering:

```rust
use gpui::{rgb, Rgba};
use crate::{designs::{get_tokens, DesignVariant}, theme};

pub struct DesignContext<'a> {
    pub variant: DesignVariant,
    pub theme: &'a theme::Theme,
    pub tokens: crate::designs::DesignTokens, // whatever your token type is
    pub c: ResolvedColors,
}

pub struct ResolvedColors {
    pub bg_main: u32,
    pub bg_secondary: u32,
    pub bg_tertiary: u32,
    pub border: u32,
    pub text_primary: u32,
    pub text_secondary: u32,
    pub text_muted: u32,
    pub text_dimmed: u32,
    pub accent: u32,
    pub bg_selected: u32,
    pub text_on_accent: u32,
}

impl<'a> DesignContext<'a> {
    pub fn new(theme: &'a theme::Theme, variant: DesignVariant) -> Self {
        let tokens = get_tokens(variant);
        let d = tokens.colors();

        let c = if variant == DesignVariant::Default {
            ResolvedColors {
                bg_main: theme.colors.background.main,
                bg_secondary: theme.colors.background.search_box,
                bg_tertiary: theme.colors.background.search_box, // pick a mapping you can live with
                border: theme.colors.ui.border,
                text_primary: theme.colors.text.primary,
                text_secondary: theme.colors.text.secondary,
                text_muted: theme.colors.text.muted,
                text_dimmed: theme.colors.text.dimmed,
                accent: theme.colors.accent.selected,
                bg_selected: theme.colors.accent.selected,
                text_on_accent: theme.colors.text.primary, // or a dedicated token if you have it
            }
        } else {
            ResolvedColors {
                bg_main: d.background,
                bg_secondary: d.background_secondary,
                bg_tertiary: d.background_tertiary,
                border: d.border,
                text_primary: d.text_primary,
                text_secondary: d.text_secondary,
                text_muted: d.text_muted,
                text_dimmed: d.text_dimmed,
                accent: d.accent,
                bg_selected: d.background_selected,
                text_on_accent: d.text_on_accent,
            }
        };

        Self { variant, theme, tokens, c }
    }

    #[inline] pub fn bg_main(&self) -> Rgba { rgb(self.c.bg_main) }
    #[inline] pub fn bg_secondary(&self) -> Rgba { rgb(self.c.bg_secondary) }
    #[inline] pub fn border(&self) -> Rgba { rgb(self.c.border) }
    #[inline] pub fn text_secondary(&self) -> Rgba { rgb(self.c.text_secondary) }
    #[inline] pub fn text_muted(&self) -> Rgba { rgb(self.c.text_muted) }
    #[inline] pub fn bg_selected(&self) -> Rgba { rgb(self.c.bg_selected) }
    #[inline] pub fn text_on_accent(&self) -> Rgba { rgb(self.c.text_on_accent) }
}
```

Then in renders: **stop referencing** `self.theme.colors...` directly. Use `dc`.

This prevents the exact inconsistency currently present in Template/Select/Drop.

---

### C) Fix `SelectPrompt` focused/selected colors and layout

Concrete fixes:

1. Use a row for checkbox + a column for text.
2. If focused: use `text_on_accent`.
3. Don’t make checkbox the same color as its background.

Sketch:

```rust
let dc = DesignContext::new(&self.theme, self.design_variant);

let row_bg = if is_focused { dc.bg_selected() } else { dc.bg_main() };
let fg = if is_focused { dc.text_on_accent() } else { dc.text_secondary() };
let muted = if is_focused { dc.text_on_accent() } else { dc.text_muted() };

let checkbox_fg = if is_selected {
    // if focused, keep it readable; if not focused, you can use accent color
    if is_focused { dc.text_on_accent() } else { rgb(dc.c.accent) }
} else {
    muted
};

div()
  .flex()
  .flex_row()
  .items_center()
  .bg(row_bg)
  .child(div().text_color(checkbox_fg).child(checkbox))
  .child(
      div()
        .flex_1()
        .flex()
        .flex_col()
        .child(div().text_color(fg).child(choice.name.clone()))
        .when_some(choice.description.as_ref(), |d, desc| {
            d.child(div().text_sm().text_color(muted).child(desc.clone()))
        })
  );
```

This solves readability and the “desc in same row” problem.

---

### D) Make Arg/Select lists scroll (minimum viable fix)

Change list container to scroll:

* Ensure it’s stateful (`.id(...)` already present)
* Replace `overflow_y_hidden()` with `overflow_y_scroll()`

Example:

```rust
let mut choices_container = div()
    .id(gpui::ElementId::Name("list:choices".into()))
    .flex()
    .flex_col()
    .flex_1()
    .min_h(px(0.))
    .w_full()
    .overflow_y_scroll(); // not hidden
```

If GPUI requires `track_scroll`, add a `ScrollHandle` like DivPrompt.

Then (optional but recommended): when focus/selection changes, scroll to keep it visible. (Exact API depends on GPUI; implement once you know the primitives.)

---

### E) Cache `DivPrompt` parsing

Add fields:

```rust
pub struct DivPrompt {
    // ...
    parsed: Vec<HtmlElement>,
    parsed_dirty: bool,
    // optionally cached TailwindStyles if you parse frequently:
    cached_root_styles: Option<TailwindStyles>,
    cached_container_styles: Option<TailwindStyles>,
}
```

Update constructors to parse once:

```rust
let parsed = parse_html(&html);
DivPrompt { html, parsed, parsed_dirty: false, ... }
```

Add setter(s) that mark dirty:

```rust
pub fn set_html(&mut self, html: String, cx: &mut Context<Self>) {
    if self.html == html { return; }
    self.html = html;
    self.parsed = parse_html(&self.html);
    cx.notify();
}
```

Then in `render()` use `&self.parsed` and remove `parse_html()` from render.

This is a big, immediate win.

---

### F) Stabilize semantic IDs across filtering

In ArgPrompt:

```rust
let semantic_id = choice.semantic_id.clone().unwrap_or_else(|| {
    // use choice_idx (stable) not idx (display)
    generate_semantic_id("choice", choice_idx, &choice.value)
});
```

Same in SelectPrompt.

---

### G) Back-compat check: `SelectPrompt` submit format

Right now you always return a JSON array string. If legacy Script Kit expects:

* single-select → `"value"`
* multi-select → `["a","b"]`

…then this is a breaking change.

**Low-risk option:**

```rust
fn submit(&mut self) {
    let selected_values: Vec<String> = ...;

    if !self.multiple {
        let v = selected_values.into_iter().next();
        self.on_submit(self.id.clone(), v);
        return;
    }

    let json_str = serde_json::to_string(&selected_values).unwrap_or_else(|_| "[]".into());
    (self.on_submit)(self.id.clone(), Some(json_str));
}
```

If you’re sure legacy always wants JSON, ignore this — but given your constraints, I’d treat this as “verify and lock down”.

---

## Bottom line

If you do only three things in Bundle 38, do these:

1. **Introduce `PromptBase` (struct) + `impl_focusable_via_base!`** and migrate prompts one-by-one.
2. **Introduce `DesignContext` and ban direct theme/token color access in prompt rendering.** That kills branching *and* prevents mixed-theme regressions.
3. **Fix `DivPrompt` parsing-in-render + fix `SelectPrompt` focused/selected colors.** Those are immediate correctness + perf wins.

Everything else (generic render wrappers, key routing, virtualization) becomes much easier once those foundations are in place.
