Below is a focused review of the **two files in the snapshot** (`src/config/types.rs`, `src/hud_manager.rs`) through the lens of your “Bundle 33: Deep Links” goals *and* the app’s constraints (instant launcher, multi-window, theme hot reload, backwards compat).

You don’t have any actual deep-link handler/routing implemented yet, so the most important deep-link-relevant finding in this snapshot is the **scheme/format mismatch** and some **HUD manager correctness issues** that will bite you once deep links start driving HUD feedback/errors.

---

## 1) Critical issues

### 1.1 Deeplink scheme mismatch (`scriptkit` registered, but helper returns `kit://...`)

You register:

* `osx_url_schemes = ["scriptkit"]`

But `command_id_to_deeplink()` returns:

* `kit://commands/{commandId}`

That means:

* If anything in the app (or scripts/docs) uses `command_id_to_deeplink()`, it will generate links that **won’t open your app**, because `kit` is not registered.
* Also: your proposed new scheme patterns are `scriptkit://run/...`, `scriptkit://command/...`, etc — totally different shape than `kit://commands/...`.

**Fix direction**

* Decide your canonical scheme (`scriptkit`), then:

  * Update `command_id_to_deeplink()` to emit `scriptkit://...`
  * And for backwards compatibility: **register both schemes** (`scriptkit` and `kit`) OR support both formats in your router (best: both).

This is a “day-one” issue for Bundle 33.

---

### 1.2 HUD stacking can overlap windows (real bug)

Stack offset is computed as:

```rust
state.active_huds.len() as f32 * HUD_STACK_GAP
```

But you remove HUDs with `swap_remove` in `dismiss_hud_by_id()`. This combination means:

* HUDs can expire out-of-order (different durations, delays, action HUD default 3000ms vs normal 2000ms).
* If a “middle” HUD disappears first, you get a gap.
* The next HUD uses `len * gap`, which can place it **on top of an existing HUD**.

This leads to:

* overlapping HUD windows
* `close_hud_window_by_bounds()` potentially closing/configuring the wrong window (because bounds collisions become possible)

**Fix direction**

* Track a **slot index** per HUD (0..MAX-1) and always position by slot, not by `len`.
* Allocate the lowest free slot; free it on dismiss.

---

### 1.3 `cleanup_expired_huds()` can desync state from real windows

`cleanup_expired_huds()` does:

```rust
state.active_huds.retain(|hud| !hud.is_expired());
```

But it **does not close windows** for those removed HUDs.

If a HUD is considered “expired” by elapsed time, but its timer callback hasn’t yet closed it (main thread backlog / timer scheduling ordering), then:

* it gets dropped from `active_huds`
* later its timer fires → `dismiss_hud_by_id()` won’t find it → logs “already dismissed” and **doesn’t close**
* leaving an orphan HUD window visible until app restart (depending on GPUI window lifecycle)

Even if this only happens under load, Bundle 33 deep links will increase “under load” cases (external triggers, rapid actions).

**Fix direction**

* Either remove the “time-based retain cleanup” entirely and trust the timer/explicit dismiss…
* Or if you keep it, you must **close** any HUD you remove and do it by a stable identifier.

---

### 1.4 Closing/configuring NSWindows by bounds is brittle (and can hit the wrong window)

Both `configure_hud_window_by_bounds()` and `close_hud_window_by_bounds()`:

* enumerate `NSApp().windows`
* match by approximate `(x,y,width,height)`

This is risky because:

* bounds math can differ by scale factor (retina, fractional pixels)
* GPUI’s coordinate space may not be identical to Cocoa frame coordinates (depends on GPUI)
* any accidental overlap (see stacking bug) makes collisions likely
* any other internal app window with same bounds could get configured/closed

**Fix direction**

* Prefer a stable identifier:

  * set a unique window title (even if titlebar is None, title still exists) if GPUI exposes it
  * or attach an identifier to the NSWindow (if you can get the raw NSWindow handle)
* If you truly can’t, add a second discriminator beyond bounds:

  * a unique title
  * an accessibility identifier
  * or even check content view class / properties (harder)

---

### 1.5 Non-macOS behavior: HUDs never close

On non-macOS:

```rust
fn close_hud_window_by_bounds(...) {
    logging::log("HUD", "Non-macOS: HUD window cleanup not implemented");
}
```

But you still create windows and schedule timers. Result: **HUDs leak windows** on other platforms.

If you’re truly macOS-only, consider compiling this module only on macOS.
If you plan to be cross-platform later, you need a cross-platform close path (ideally via GPUI handle).

---

## 2) Performance concerns (practical, not theoretical)

### 2.1 Enumerating all windows for every HUD show/close

Every HUD show:

* `configure_hud_window_by_bounds()` scans all app windows

Every dismiss:

* `close_hud_window_by_bounds()` scans all app windows

This is probably fine at low volume, but if scripts start firing HUDs in loops (or deep links trigger bursts), you’ll see:

* unnecessary AppKit work on the main thread
* extra overhead during “launcher must feel instant” moments

**Fix direction**

* store a direct handle/identifier to the NSWindow if possible
* or reduce scanning by using a stable identifier lookup (title/identifier) instead of fuzzy bounds

---

### 2.2 Unbounded pending queue can become a memory sink

`pending_queue` has no cap. If something spams HUDs faster than they dismiss, memory grows without bound.

**Fix direction**

* cap queue length (e.g., 50 / 100)
* optionally coalesce duplicates (same message) or drop oldest

---

### 2.3 Theme loading on every HUD creation

`HudColors::from_theme()` calls `theme::load_theme()` each HUD creation. Depending on implementation, that could be:

* cheap (cached in memory)
* or expensive (disk read / parsing)

If it’s not already cached, HUD spam becomes expensive.

**Fix direction**

* keep a cached theme snapshot or subscribe HUD view to your theme store (fits your “theme hot-reload across all windows” constraint)

---

## 3) API design feedback

### 3.1 `show_hud` vs `show_hud_with_action` is duplicate code

These functions are almost the same; they differ only in:

* size constants
* action presence
* click-through toggle
* default duration

You already have `HudNotification` and a `show_notification()` helper — that’s the right shape, but the public API doesn’t lean into it.

**Better API**

* Make the public API accept `HudNotification` (or a builder), and keep a single code path.
* Expose “action HUD” purely via fields on the notification.

Example:

```rust
pub fn show(notif: HudNotification, cx: &mut App) { ... }
```

Then helper constructors:

```rust
impl HudNotification {
    pub fn plain(text: impl Into<String>) -> Self { ... }
    pub fn with_action(text: impl Into<String>, label: impl Into<String>, action: HudAction) -> Self { ... }
}
```

---

### 3.2 `HudAction::RunCommand(String)` is the wrong abstraction

A stringly-typed shell command that you split on whitespace is both:

* incorrect for quoted args
* a footgun for behavior differences

**Better**

* represent it as `(program, args)`:

```rust
RunCommand { program: String, args: Vec<String> }
```

If you truly want a shell, make it explicit:

```rust
RunShell(String) // runs "sh -lc <string>"
```

---

### 3.3 Deep link generation should not live in `config/types.rs`

`command_id_to_deeplink()` is more of a “routing/protocol” concern than a config type concern. It also currently hardcodes an outdated format.

**Better**

* move into a `deeplink` module that owns:

  * scheme(s)
  * parsing + routing
  * formatting helpers
  * percent-encoding rules

This will matter when you support multiple URL shapes (`kit://commands/...` and the new `scriptkit://...` patterns).

---

## 4) Simplification opportunities

### 4.1 Remove `Arc` around the HUD manager singleton

You have:

```rust
static HUD_MANAGER: OnceLock<Arc<Mutex<HudManagerState>>> = ...
```

…but you never clone and share the `Arc` beyond internal use. You can simplify to:

```rust
static HUD_MANAGER: OnceLock<Mutex<HudManagerState>> = OnceLock::new();
```

and return `&'static Mutex<HudManagerState>`.

Less indirection, less heap allocation, simpler mental model.

---

### 4.2 Replace “len-based stacking” with slot-based stacking

Given `MAX_SIMULTANEOUS_HUDS` is small, treat it like a fixed pool. This eliminates:

* overlap bugs
* need for “expired retain cleanup” hacks
* a bunch of logging around “could not find window” caused by collisions

---

### 4.3 Drop time-based cleanup unless you also close windows

Right now `cleanup_expired_huds()` is trying to do two jobs:

* “remove expired” (but doesn’t close)
* “show pending if room”

Split responsibilities:

* `show_pending_if_room()`
* optionally `sweep_and_close_expired()` (must close as it removes)

Or just rely on timers + explicit dismiss.

---

## 5) Specific recommendations with concrete code examples

### 5.1 Fix scheme mismatch now

If `scriptkit` is the canonical scheme, change this:

```rust
pub fn command_id_to_deeplink(command_id: &str) -> String {
    format!("kit://commands/{}", command_id)
}
```

To something like:

```rust
pub const DEEPLINK_SCHEME_PRIMARY: &str = "scriptkit";
pub const DEEPLINK_SCHEME_LEGACY: &str = "kit"; // optional

pub fn command_id_to_deeplink(command_id: &str) -> String {
    // If command_id may contain characters that need encoding, encode it.
    // (At minimum, be careful with spaces and '#', '?', '%'.)
    format!("{DEEPLINK_SCHEME_PRIMARY}://commands/{}", command_id)
}
```

Then in Bundle 33 router, support both `scriptkit://...` and `kit://...` inputs.

Also: if you keep the new patterns (`/command/...` vs `/commands/...`), either:

* map legacy → new internally, or
* support both paths.

---

### 5.2 Replace HUD stacking with slot allocation (eliminates overlap)

Change state to track slots:

```rust
const MAX_SIMULTANEOUS_HUDS: usize = 3;

struct HudManagerState {
    active: [Option<ActiveHud>; MAX_SIMULTANEOUS_HUDS],
    pending_queue: VecDeque<HudNotification>,
}

impl HudManagerState {
    fn new() -> Self {
        Self {
            active: std::array::from_fn(|_| None),
            pending_queue: VecDeque::new(),
        }
    }

    fn first_free_slot(&self) -> Option<usize> {
        self.active.iter().position(|s| s.is_none())
    }

    fn active_count(&self) -> usize {
        self.active.iter().filter(|s| s.is_some()).count()
    }
}
```

Add a `slot` field:

```rust
struct ActiveHud {
    id: u64,
    window: WindowHandle<HudView>,
    bounds: gpui::Bounds<Pixels>,
    slot: usize,
    created_at: Instant,
    duration_ms: u64,
}
```

When showing a HUD, allocate slot first:

```rust
let slot = {
    let manager = get_hud_manager();
    let state = manager.lock();
    state.first_free_slot()
};

if let Some(slot) = slot {
    let stack_offset = slot as f32 * HUD_STACK_GAP;
    // use stack_offset
} else {
    // queue
}
```

When dismissing by id, clear that slot:

```rust
fn dismiss_hud_by_id(hud_id: u64, cx: &mut App) {
    let manager = get_hud_manager();

    let to_close = {
        let mut state = manager.lock();
        let mut found: Option<gpui::Bounds<Pixels>> = None;

        for slot in 0..MAX_SIMULTANEOUS_HUDS {
            if let Some(hud) = &state.active[slot] {
                if hud.id == hud_id {
                    found = Some(hud.bounds);
                    state.active[slot] = None;
                    break;
                }
            }
        }

        found
    };

    if let Some(bounds) = to_close {
        close_hud_window_by_bounds(bounds);
        show_pending_if_room(cx);
    }
}
```

And implement `show_pending_if_room()` with slots. That also replaces `cleanup_expired_huds()` as currently written.

This single change kills:

* overlap bugs
* “retain expired but not closed” failure mode (if you drop that logic)
* a big chunk of complexity

---

### 5.3 Cap the pending queue (prevents memory blowups)

Add:

```rust
const MAX_PENDING_HUDS: usize = 50;
```

When queueing:

```rust
if state.pending_queue.len() >= MAX_PENDING_HUDS {
    // Drop oldest (or newest). Oldest is usually better.
    state.pending_queue.pop_front();
}
state.pending_queue.push_back(notif);
```

Optionally coalesce duplicates:

* If last pending text matches new, skip
* If a HUD with same text is already active, skip

---

### 5.4 Stop removing expired HUDs without closing them

If you keep an “expired sweep”, it must close.

A safe pattern:

```rust
fn sweep_and_close_expired(cx: &mut App) {
    let manager = get_hud_manager();
    let expired_bounds: Vec<gpui::Bounds<Pixels>> = {
        let mut state = manager.lock();
        let mut expired = Vec::new();

        for slot in 0..MAX_SIMULTANEOUS_HUDS {
            if let Some(hud) = &state.active[slot] {
                if hud.is_expired() {
                    expired.push(hud.bounds);
                    state.active[slot] = None;
                }
            }
        }

        expired
    };

    for bounds in expired_bounds {
        close_hud_window_by_bounds(bounds);
    }

    show_pending_if_room(cx);
}
```

…but honestly: if you trust timers, just delete the sweep entirely and only manage pending when a slot is freed.

---

### 5.5 Make NSWindow matching less dangerous

If GPUI lets you set a title in `WindowOptions`, set it to include the HUD id:

* `ScriptKitHUD:<id>`

Then in AppKit search, match by title first, bounds second.

If GPUI doesn’t let you set a title, consider adding a platform shim that:

* retrieves the NSWindow pointer from the GPUI window (if accessible)
* sets the identifier immediately

Even if you keep bounds matching as a fallback, add an attempt/retry because you may call configure before the window is actually present in `NSApp.windows`.

---

### 5.6 Deep link router recommendations aligned with your questions

Even though it’s not implemented in this snapshot, your design choices affect everything:

**Authority format**

* Prefer `scriptkit://run/<...>` (your current proposal) because it:

  * parses cleanly with standard URL libs
  * matches common macOS deep link patterns (host = “action”)
* Also support `scriptkit:///run/<...>` just in case some clients generate empty-host URLs.

**Script matching**

* Default: deterministic only

  * exact match
  * case-insensitive
  * `.ts` extension optional
  * slug normalization (spaces → `-`, lowercasing)
* Avoid edit-distance fuzzy by default (it’s too easy to run the wrong script). If you want it:

  * gate behind `?fuzzy=true` or config flag
  * if multiple matches, open UI and require explicit selection (or return x-error)

**Security**
Minimum sane baseline:

* Allow “non-executing” routes without prompts: `open`, `hide`, `settings`, `search`
* For `run` / `action` / `snippet`:

  * default to **show UI + confirmation** unless script is explicitly allowlisted
  * disallow `silent=true` unless allowlisted
* Store allowlist in config (or SQLite) and expose UI to manage it

This balances automation with “webpage can trigger script execution” risk.

**x-callback-url results**

* For small outputs: percent-encoded JSON in a `result=` parameter
* For larger outputs: write temp file and return `result_file=` (file URL) or `result_path=` (path)
* Always return structured errors to `x-error` with:

  * `errorCode=...`
  * `errorMessage=...`

**Browser extension**

* Optional, not required for MVP.
* Deep links alone get you 80% (button → open scheme).
* If you do an extension later, you’ll likely want:

  * a user gesture click to trigger the scheme
  * plus maybe a native helper if you want richer messaging (otherwise browsers may block/confirm)

---

## URLs mentioned

* `scriptkit://run/<script-name>`
* `scriptkit://command/<built-in-command>`
* `scriptkit://action/<action-name>`
* `scriptkit://search?q=<query>`
* `scriptkit://snippet/<snippet-id>`
* `scriptkit://open`
* `scriptkit://hide`
* `scriptkit://settings`
* `scriptkit://settings/<section>`
* `scriptkit://commands/<commandId>`
* `kit://commands/<commandId>`
