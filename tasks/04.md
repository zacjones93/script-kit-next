## 1) Critical issues

### A. Your scrollbar is built from stale / guessed state

Right now you compute:

* `estimated_container_height = 400`
* `scroll_offset = self.main_list_state.logical_scroll_top().item_ix`
* then **afterwards** you may `reset(item_count)` and you always `scroll_to_reveal_item(selected)`

So the scrollbar inputs can be wrong for *this frame* (and can be wrong forever if `estimated_container_height` doesn’t match reality). That’s why the thumb can feel laggy / inaccurate even when your list is correct.

**Fix:** drive the scrollbar from `ListState`’s scrollbar APIs and actual viewport size:

* `viewport_bounds()` for the real list viewport height
* `scroll_px_offset_for_scrollbar()` for current scroll offset in pixels
* `max_offset_for_scrollbar()` for total scrollable range in pixels

This eliminates your need to “know total content height” just to size the thumb.

---

### B. `reset()` inside render can break scroll-driven UI (and matches your “scrolling breaks” symptom)

`ListState::reset` explicitly drops scroll events until the list is painted at least once.
If you’re using scroll events (directly or indirectly) to set `is_scrolling` for your fade-out scrollbar, resetting in the middle of render is a great way to get weird “sometimes scrolling breaks” behavior.

**Fix:** do list-state maintenance in one place (a state update path), and prefer less-destructive APIs when possible:

* `set_item_count` or `splice` when only count/ranges change
* reserve `reset` for “data is totally different” (big reorder + height cache invalidation)

---

### C. You’re forcing “keep selection visible” every frame

This line runs every render:

```rust
self.main_list_state.scroll_to_reveal_item(self.selected_index);
```

That will fight any attempt at “free scroll” (trackpad scrolling, dragging a scrollbar, inertial scrolling) because the scroll position gets pulled back to keep selection visible — even when the selection didn’t change.

**Fix:** only call `scroll_to_reveal_item` when selection changes *or* when the dataset change invalidates visibility. (Concrete code below.)

Also note: `scroll_to_reveal_item` is already the “nearest/minimal” behavior in the variable-height list world; you don’t need strategy gymnastics for keyboard nav if you use it correctly.

---

### D. Your scroll-wheel handler is mixing two scroll models (and may double-scroll)

You wrap the list in a container with `.on_scroll_wheel(...)`, but the list itself is configured to be scrollable (you even note `Infer` sets overflow scroll internally). If both the list and your wrapper receive wheel events, you can get:

* list scroll moves a bit (broken because unmeasured items),
* then selection changes + `scroll_to_reveal_item` moves again.

That is prime “jank generator”.

**Fix:** pick one model:

1. **Command-palette model** (recommended for Script Kit):

   * wheel moves selection (index-based)
   * list only scrolls to reveal selection
   * wheel event must be *consumed* so native scrolling doesn’t also happen

2. **Real scroll model**:

   * wheel scrolls pixels
   * selection follows scroll (optional)
   * use `ListState`’s scrollbar APIs, and (if needed) address measurement properly

Right now you’re half-in/half-out.

---

### E. Selection can still land on a header in edge cases

You do a “move down to first Item” when the selected index is a header. But if:

* the list is only headers (possible depending on grouping logic), or
* you land on a header at the end and there’s no item after it,

then selection stays on a header and `execute_selected` (Enter / double click) can blow up or become a no-op.

**Fix:** when coercing selection off a header:

* try down first
* if nothing found, try up
* if still nothing found, disable “execute” and keep selection = `None` (or 0) in this mode.

---

## 2) Performance concerns

### A. You are cloning big vectors more than you think

At the top:

```rust
let (grouped_items, flat_results) = self.get_grouped_results_cached();
let grouped_items = grouped_items.clone();
let flat_results = flat_results.clone();
```

Then again inside the list branch:

```rust
let grouped_items_clone = grouped_items.clone();
let flat_results_clone = flat_results.clone();
```

If `flat_results` contains real `SearchResult` structs (strings, metadata), this is an O(n) clone **every render**. That’s far worse than your O(n) header counting.

**Fix:** make these caches reference-counted:

* `Arc<[GroupedListItem]>`
* `Arc<[SearchResult]>` (or `Arc<Vec<SearchResult>>`)

Then cloning is O(1) and you stop paying for copies each frame.

---

### B. O(n) height math every render is self-inflicted

You count headers/items each render just to compute `total_content_height`.

If you keep your current scrollbar model (item-count-based), do the counting when you build the cache:

* store `header_count`, `item_count_regular`, and `total_content_height` alongside `grouped_items`.

Then render-time is O(1).

If you move to ListState-driven scrollbar, you don’t need your own total height at all.

---

### C. `entity.update` per row is heavier than it needs to be

Your row renderer does:

```rust
entity.update(cx, |this, cx| { ... })
```

for every visible row.

Even if you don’t mutate, you’re taking the “write” path and doing closure work at render time. Prefer:

* `entity.read(cx)` for reading selected/hovered
* only mutate inside event handlers

This tends to reduce internal contention and makes re-renders cheaper.

---

### D. You compute expensive item UI even when you replace it

In the pending-confirmation case you still call `render_design_item(...)` and then throw it away in favor of the warning overlay.

**Fix:** short-circuit:

* if pending && selected: render overlay directly
* else: render full item

This matters when you have lots of visible items and heavy item renderers.

---

### E. Wheel “rounding” makes trackpads feel bad and can skip too much

You do:

```rust
let item_delta = -lines.round() as i32;
```

High-resolution trackpads produce lots of fractional deltas; rounding loses information and feels sticky/jumpy. Also large deltas can jump across multiple headers/items.

**Fix:** accumulate fractional deltas and only apply integer steps when magnitude crosses 1.0 (code below).

---

## 3) API design feedback

### A. Centralize list responsibilities: model vs view vs state

Right now `render_script_list` is doing:

* selection validity enforcement
* item-count sync / reset logic
* scroll management
* wheel event translation
* scrollbar math
* item rendering
* confirmation overlay branching
* hover/click mechanics

That’s too much in one function. It makes small list changes risky.

**Recommendation:** introduce two small structs:

**1) `Rows` (pure model)**

* flattened rows: `enum Row { Header(..), Item { result_ix: usize } }`
* cached counts/heights if needed
* selection helpers: `is_selectable(ix)`, `next_selectable(ix, dir)`

**2) `ListController` (state glue)**

* owns `ListState`
* owns “last revealed index”
* owns wheel accumulator
* sync method: `sync(item_count, selected_index_changed, cx)`

This keeps `render_*` mostly declarative.

---

### B. Use the `ListState` APIs that already exist for custom scrollbars

You’re re-deriving information that `ListState` can already provide:

* viewport bounds (real container height)
* scroll offset for scrollbars (pixels)
* max scroll offset (pixels)
* interactive scrollbar control (`set_offset_from_scrollbar`, drag start/end)

This is exactly what you need for “manual scrollbar with fade-out animation” without iterating items.

---

## 4) Simplification opportunities

### A. Don’t fight `list()`—either commit to it or stop using it

If your primary behavior is “command palette selection list”, you don’t actually need pixel-perfect smooth scrolling. You need:

* fast selection navigation
* list scrolls enough to keep selection visible
* thumb gives approximate context

In that case:

* keep `list()`
* stop trying to mimic a full scroll view
* keep wheel->selection, but consume the wheel event and stop thinking in pixels

If you *do* want full free scrolling + accurate thumb:

* rely on `ListState` scrollbar APIs
* and address measurement.

(If you’ve been bitten by “unmeasured items = 0px”, note `ListState::measure_all()` exists specifically to ensure scrollbars/content size aren’t based only on rendered items.
But measuring all with a heavy row closure can be expensive — see recommendations below.)

---

### B. Headers should stay flattened

You already have `GroupedListItem::{SectionHeader, Item}` in one list. That’s the right shape.

Keeping headers “separate” creates two index spaces and doubles the number of edge cases (scroll mapping, selection mapping, “scroll to item” mapping).

Flattening is correct; just make selection explicitly “only item rows selectable”.

---

## 5) Specific recommendations with concrete code changes

### 5.1 Stop cloning results every render (biggest win)

Change your cached results return type to something like:

```rust
use std::sync::Arc;

pub struct CachedResults {
    pub rows: Arc<[GroupedListItem]>,
    pub results: Arc<[scripts::SearchResult]>,
    pub header_count: usize,
    pub item_count: usize,
    pub total_height_px: f32, // if you keep your own thumb math
}
```

Then in render:

```rust
let cached = self.get_grouped_results_cached(); // returns CachedResults (cheap clone)
let rows = Arc::clone(&cached.rows);
let results = Arc::clone(&cached.results);
```

Now you can pass `rows` / `results` into closures without deep cloning.

---

### 5.2 Make selection skipping iterative and total (no recursion, no stack risk)

Create a helper that always finds a selectable row or returns None:

```rust
fn coerce_selection(rows: &[GroupedListItem], mut ix: usize) -> Option<usize> {
    if rows.is_empty() {
        return None;
    }

    // Clamp first
    ix = ix.min(rows.len() - 1);

    // If selectable, done
    if matches!(rows[ix], GroupedListItem::Item(_)) {
        return Some(ix);
    }

    // Search down
    for j in (ix + 1)..rows.len() {
        if matches!(rows[j], GroupedListItem::Item(_)) {
            return Some(j);
        }
    }

    // Search up
    for j in (0..ix).rev() {
        if matches!(rows[j], GroupedListItem::Item(_)) {
            return Some(j);
        }
    }

    None
}
```

Use it both after dataset changes and after navigation.

If it returns None, disable enter/double-click execution for this state.

---

### 5.3 Only reveal selection when selection changes

Add a field:

```rust
last_revealed_selection: Option<usize>,
```

Then in render (or better: in your “apply selection change” path):

```rust
if self.last_revealed_selection != Some(self.selected_index) {
    self.main_list_state.scroll_to_reveal_item(self.selected_index);
    self.last_revealed_selection = Some(self.selected_index);
}
```

This stops the list from constantly yanking scroll position during normal renders.

---

### 5.4 Replace `reset` with `splice` (or `set_item_count`) when possible

If you’re only changing the count (e.g., filter result count changes), you can do:

```rust
let old = self.main_list_state.item_count();
if old != new_count {
    self.main_list_state.splice(0..old, new_count);
}
```

`splice` exists for exactly this “items replaced, recompute layout in a range” use case.

Reserve `reset(new_count)` for “totally different list, throw away all measurement cache”.

---

### 5.5 Fix wheel scrolling feel with an accumulator

Add:

```rust
wheel_accum: f32,
```

Then:

```rust
.on_scroll_wheel(cx.listener(move |this, event: &gpui::ScrollWheelEvent, _window, cx| {
    let delta_lines: f32 = match event.delta {
        gpui::ScrollDelta::Lines(p) => p.y,
        gpui::ScrollDelta::Pixels(p) => {
            let pixels: f32 = p.y.into();
            pixels / 44.0 // or compute from known heights
        }
    };

    // Accumulate smoothly
    this.wheel_accum += -delta_lines; // invert so “scroll down” moves selection down

    let steps = this.wheel_accum.trunc() as i32;
    if steps != 0 {
        this.wheel_accum -= steps as f32;
        this.move_selection_by(steps, cx);
    }

    // IMPORTANT: consume the event so the list doesn't also try to scroll.
    // (Actual API name depends on gpui; the key point is: prevent double-handling.)
}))
```

This preserves smooth scrolling and makes trackpads feel “right”.

---

### 5.6 Drive the scrollbar from `ListState` instead of manual height iteration

If you want a thumb that actually tracks the list, use:

* `viewport_bounds()`
* `scroll_px_offset_for_scrollbar()`
* `max_offset_for_scrollbar()`

Pseudo-code:

```rust
let viewport = self.main_list_state.viewport_bounds();
let viewport_h: f32 = viewport.size.height.into();

let max = self.main_list_state.max_offset_for_scrollbar();
let max_y: f32 = max.height.into();

let offset = self.main_list_state.scroll_px_offset_for_scrollbar();
let y: f32 = offset.y.into();

// total content = viewport + max scroll range
let content_h = viewport_h + max_y;

// thumb size = viewport/content, clamped
let thumb_h = (viewport_h * (viewport_h / content_h))
    .clamp(24.0, viewport_h); // choose a min thumb height

let thumb_y = if max_y > 0.0 {
    (y / max_y) * (viewport_h - thumb_h)
} else {
    0.0
};
```

Then your `Scrollbar` component can just take `thumb_h` and `thumb_y` in pixels.
Bonus: if you want an interactive thumb, `ListState::set_offset_from_scrollbar` is designed for that.

---

### 5.7 If you want true free scrolling: the real fix is measurement, not hacks

Your comment says unmeasured items show up as 0px height and scroll can’t reach them. That’s exactly the class of problem `ListState::measure_all()` exists to address (“ensure scrollbar size is correct instead of based on only rendered elements”).

**But**: calling `measure_all()` with your current heavy row closure will likely be expensive at 1000+ items.

If you go this route, you need to make “measurement render” cheap. Since `list()` doesn’t pass a “measuring mode” flag into the closure, the pragmatic workaround is usually:

* keep command-palette style scrolling (selection-based), OR
* roll your own list where you can separate “height model” from “row render”.

Given your constraints (“launcher appears instantly”), I would not blindly enable `measure_all()` on a heavy list.

---

## Answers to your original “Expert Question 4” bullets (in the context of what you have)

1. **Is GPUI `list()` the right tool, or roll your own?**
   For your *current* variable heights (only 24 and 48), `list()` is fine **if you treat this as a selection list**. If you need full free scrolling + accurate scrollbar without measuring everything, rolling your own becomes more attractive.

2. **Avoid O(n) height calc with variable heights?**

* If heights are deterministic (your case): cache counts/total height at build time (O(1) in render).
* If heights are truly dynamic: you need a height cache + prefix sums (Fenwick tree / segment tree) or you accept measurement work. `ListState` can supply pixel scroll metrics for scrollbars once it knows sizes.

3. **Right scroll strategy for keyboard nav?**
   For command palettes: *minimal scroll to full visibility* (what `scroll_to_reveal_item` does).
   Centering is for “jump to match / search result” experiences, not per-arrow navigation.

4. **Flatten headers or keep separate?**
   Flatten (you already do). Just make headers non-selectable and centralize that logic.

5. **How does Zed’s file tree handle this?**
   Zed’s project/outline panels heavily lean on *uniform list patterns* with scroll handles and decorations (indent guides, sticky items), and they scroll to item indices with a scroll handle (rather than making rows variable-height). You can see the project panel calling `scroll_handle.scroll_to_item(...)` in their panel code patterns.
   Translation: they avoid variable-height rows in these perf-critical trees.

---

```text
URLs referenced
- https://docs.rs/gpui/latest/gpui/struct.ListState.html
- https://docs.rs/gpui/latest/gpui/struct.UniformListScrollHandle.html
- https://docs.rs/gpui/latest/gpui/enum.ScrollStrategy.html
- https://git.icanbuildit.io/Yehowshua/ZIm/commit/3a247ee94760541906488b4145148964fce709a3
```
