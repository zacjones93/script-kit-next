Below is what I’d fix first, and why. I’m going to be blunt: the big risks here aren’t “atomic ordering” — they’re **threading/ownership guarantees**, **non‑atomic hotkey swaps**, and **the fact that your dynamic script hotkey manager is not actually wired into the listener loop**.

---

## 1) Critical issues

### 1.1 You’re creating `GlobalHotKeyManager` on the wrong thread (macOS)

`start_hotkey_listener` spawns a thread and calls `GlobalHotKeyManager::new()` inside it. The `global_hotkey` crate explicitly documents that on macOS you must create the manager on the **main thread** (because the event loop is on the main thread).

**Why this matters**

* This can work “most of the time” and then randomly fail after OS updates, under load, or when the run loop isn’t in the state you assumed.
* If hotkeys are a flagship feature, you want to be on the supported path, not relying on undefined behavior / implementation accidents.

**Fix**

* Create `GlobalHotKeyManager` on the main thread.
* Then decide whether:

  * you keep using it from other threads (it’s `Send + Sync`), or
  * you funnel register/unregister onto the main thread (safest when in doubt).

At minimum: change the API so the main thread creates the manager and passes it into the hotkey subsystem (or stores it in a main-thread-owned service).

---

### 1.2 Dynamic script hotkeys are not wired into the event dispatcher

Your listener loop uses a **local** `script_hotkey_map` created inside `start_hotkey_listener` and never updates it. But your “dynamic” `ScriptHotkeyManager` lives in a completely different global singleton and the listener loop never consults it.

**Result**

* “Hot-reload” for script hotkeys cannot work end-to-end as written.
* If you *do* register script hotkeys later via `register_script_hotkey`, events will arrive with those IDs, but the listener loop won’t match them → nothing fires.
* Conversely, hotkeys registered at startup can’t be unregistered/updated because you don’t keep their `HotKey` objects in a place the hot-reload code can reach.

**Fix**
You need **one authoritative routing source** for script hotkeys that both:

* the event loop uses to map `event.id → path`, and
* the hot-reload updater mutates.

Right now you have *two* systems.

---

### 1.3 Hot-reload swaps are not safe/atomic: you can lose hotkeys

In `update_hotkeys`, you do:

1. unregister old
2. register new
3. store new id, store new `HotKey`

If registration fails, you’ve already thrown away the old hotkey (`take()`), so you can end up with **no hotkey at all** (especially bad for “main launcher hotkey”).

This same pattern exists in `ScriptHotkeyManager::update` (unregister then register).

**Fix pattern**

* Prefer: **register new first**, then “commit” routing/id changes, then unregister old.
* Or: if you must unregister first, then on register failure **re-register the old** (rollback).

Also: your ID publication isn’t tied to the OS registration moment. Even with atomics, there’s a window where a new hotkey is registered but your event loop still matches against old IDs (or vice versa). That can drop presses.

---

### 1.4 Your macOS GCD trampoline can cause UB on panic

Your `extern "C" fn trampoline` calls the closure directly. If the closure panics, it will unwind across an FFI boundary → **undefined behavior**.

This is a real footgun. Hotkey handlers often end up calling code that `unwrap()`s during early startup or error conditions.

**Fix**
Wrap the closure call in `std::panic::catch_unwind` inside the trampoline and log errors instead of unwinding.

---

### 1.5 You’re using `_dispatch_main_q` (private-ish) when you don’t need to

You bind the `_dispatch_main_q` symbol directly. This matches what `dispatch_get_main_queue()` effectively returns, but it’s not the nicest surface area to rely on.

Zed’s own blog example uses a binding for `dispatch_get_main_queue()` with `dispatch_async_f`. ([Zed][1])
And there are crates like `dispatch2` that provide a safe “run on main thread” API. ([Docs.rs][2])

---

### 1.6 Main hotkey failure kills the entire hotkey system

If registering the *main* hotkey fails inside `start_hotkey_listener`, you `return;` from the spawned thread — which also means:

* notes hotkey won’t run,
* AI hotkey won’t run,
* script hotkeys won’t run,
* your receiver loop never starts.

That’s a pretty harsh failure mode.

**Fix**
Keep the listener alive even if one binding fails. Mark that binding as inactive and let the user fix it via config.

---

## 2) Performance concerns

Hotkey events are not a 60fps workload — but hotkey handling must never block. A few concrete issues:

### 2.1 `send_blocking` on bounded channels can freeze hotkeys

For main hotkey and script hotkeys you do `send_blocking` into a bounded `async_channel::bounded(10)`. If the consumer is slow or blocked, your hotkey listener thread blocks.

**Impact**

* Hotkey presses stop being processed (and can appear “broken”).
* Under pressure, it can cascade into deadlocks depending on what the UI is doing.

**Fix**

* Use `try_send` and drop/coalesce when full.
* Or make the channel size 1 and treat it as an “edge-triggered pending flag”.
* Or use an unbounded channel if you’re confident presses are low volume (they are), but be deliberate.

### 2.2 Logging every event is noisy and can be expensive

You log **every hotkey event** with the ID and the current IDs. That’s fine temporarily, but it’s not something you want in a release build or during normal use.

**Fix**
Gate it behind a debug flag or log level, or sample it.

### 2.3 Unnecessary giant keycode match tables

You have a large match in `parse_hotkey_config`, and you duplicate similar matching in `start_hotkey_listener`. This is mostly maintainability, but it also slows compile times and increases bug surface.

You can shrink this substantially because `global_hotkey::hotkey::Code` implements `FromStr`. ([Docs.rs][3])
And `HotKey` is `Copy` and its `id()` is a hash of its string representation. ([Docs.rs][4])

---

## 3) API design feedback

### 3.1 Don’t expose “global mutable singleton + atomics” as your core architecture

`OnceLock<Mutex<GlobalHotKeyManager>>` + separate `OnceLock<Mutex<CurrentHotkeys>>` + three atomics is hard to reason about because:

* OS registration state lives in one place,
* routing state lives in another,
* IDs live in a third,
* and script hotkeys are split into a fourth system.

A cleaner model:

**One hotkey service owns:**

* the OS manager,
* all registered `HotKey`s,
* the routing table `id → action`,
* and applies updates as transactions.

Other parts of the app talk to it via a channel (commands), not by grabbing global locks.

### 3.2 Use a routing table, not 3 atomics + a local HashMap

The system you *want* is:

* A fast path: `match routes.get(event.id)` → dispatch
* A safe update: build a new `routes` snapshot and swap it in

Even if you keep atomics for the 3 built-ins, script hotkeys must be in a shared map, not a local variable.

### 3.3 Make update semantics explicit: “best effort” vs “transactional”

Right now:

* main hotkey failure kills the thread,
* script failures just log,
* update failures can leave you with nothing.

Pick one rule set. For a launcher app, I’d recommend:

* **Best effort per binding**, but
* **transactional update per hotkey swap** (don’t lose a working binding because the new one failed).

---

## 4) Simplification opportunities

### 4.1 Replace giant keycode match with `FromStr` parsing

`Code` implements `FromStr`, so you can do:

```rust
let code: Code = hk.key.parse().ok()?;
```

instead of the manual match. ([Docs.rs][3])

### 4.2 Collapse the 3 “current hotkey” fields into one generic helper

Main/Notes/AI update logic is the same. Use a single function that:

* parses config,
* tries to register,
* publishes new ID,
* unregisters old,
* handles rollback.

### 4.3 Reduce script maps

You don’t need 3 maps.

You need:

* `by_path: HashMap<Path, RegisteredScriptHotkey { hotkey, id, shortcut }>`
* `by_id: HashMap<u32, Path>`

`path → id` is just `by_path[path].id`.

### 4.4 Remove (or wire in) `ScriptHotkeyManager`

As-is, it’s dead weight and a correctness trap. Either:

* integrate it into the actual listener dispatch path, or
* delete it until you’re ready.

---

## 5) Specific recommendations with concrete code

### 5.1 Fix macOS thread requirement: create the manager on main thread

Change `start_hotkey_listener` to **not** create the manager internally. Instead:

```rust
pub(crate) fn start_hotkey_listener(
    manager: GlobalHotKeyManager,  // created on main thread
    config: config::Config,
) {
    // store manager globally or move into service thread
}
```

This aligns with `global_hotkey`’s documented requirement.

If you still want the receiver loop on a background thread, that’s fine — just don’t create the manager there.

---

### 5.2 Replace unsafe GCD with a crate (or at least harden your FFI)

**Best option (least footguns):** use `dispatch2`’s “run on main” API. ([Docs.rs][2])

```rust
#[cfg(target_os = "macos")]
mod gcd {
    pub fn dispatch_to_main<F: FnOnce() + Send + 'static>(f: F) {
        dispatch2::run_on_main(f);
    }
}
```

If you keep your FFI approach, do *both* of these:

1. Use `dispatch_get_main_queue()` (as in Zed’s example) ([Zed][1])
2. Catch panics in the trampoline

Example:

```rust
#[cfg(target_os = "macos")]
mod gcd {
    use std::{ffi::c_void, panic::{catch_unwind, AssertUnwindSafe}};

    #[link(name = "System", kind = "framework")]
    extern "C" {
        fn dispatch_async_f(
            queue: *mut c_void,
            context: *mut c_void,
            work: extern "C" fn(*mut c_void),
        );
        fn dispatch_get_main_queue() -> *mut c_void;
    }

    pub fn dispatch_to_main<F: FnOnce() + Send + 'static>(f: F) {
        let raw = Box::into_raw(Box::new(Box::new(f) as Box<dyn FnOnce() + Send>));

        extern "C" fn trampoline(ctx: *mut c_void) {
            unsafe {
                let boxed: Box<Box<dyn FnOnce() + Send>> = Box::from_raw(ctx as *mut _);
                let _ = catch_unwind(AssertUnwindSafe(|| boxed()));
            }
        }

        unsafe {
            dispatch_async_f(dispatch_get_main_queue(), raw as *mut c_void, trampoline);
        }
    }
}
```

---

### 5.3 Make app hotkey hot-reload transactional (no “lose hotkey on failure”)

Create one helper for Main/Notes/AI:

```rust
fn rebind_hotkey(
    manager: &GlobalHotKeyManager,
    slot: &mut Option<HotKey>,
    id_out: &AtomicU32,
    cfg: &config::HotkeyConfig,
    name: &str,
) {
    let Some((mods, code)) = parse_hotkey_config(cfg) else {
        logging::log("HOTKEY", &format!("{name} hotkey config invalid; keeping existing"));
        return;
    };

    let new_hk = HotKey::new(Some(mods), code);
    let new_id = new_hk.id();

    let old_hk = *slot;
    if old_hk.map(|h| h.id()) == Some(new_id) {
        return; // no change
    }

    // 1) Try register new first
    if let Err(e) = manager.register(new_hk) {
        logging::log("HOTKEY", &format!("Failed to register new {name} hotkey: {e}"));
        return; // keep old
    }

    // 2) Publish new routing/id ASAP (so new presses route correctly)
    *slot = Some(new_hk);
    id_out.store(new_id, Ordering::Relaxed);

    // 3) Best-effort unregister old
    if let Some(old) = old_hk {
        if let Err(e) = manager.unregister(old) {
            logging::log("HOTKEY", &format!("Warning: failed to unregister old {name} hotkey: {e}"));
            // At this point both may be registered; decide if you want to tolerate this or rollback.
        }
    }
}
```

Then `update_hotkeys` becomes a tiny wrapper that calls `rebind_hotkey` three times.

**Important:** This still allows a brief period where both bindings exist, but it prevents losing a working hotkey. If you want zero double-registration, you need an `id → action` routing table that can temporarily accept both IDs.

---

### 5.4 Replace 3 atomics + local `script_hotkey_map` with one shared routing table

You want the event loop to do something like:

```rust
enum Action {
    Main,
    Notes,
    Ai,
    Script(String),
}
```

Then:

* `HashMap<u32, Action>` is the routing table.
* For fast reads, store it behind a `RwLock` or an `ArcSwap`.

A simple first step (no new deps):

```rust
static ROUTES: OnceLock<std::sync::RwLock<HashMap<u32, Action>>> = OnceLock::new();

fn routes() -> &'static std::sync::RwLock<HashMap<u32, Action>> {
    ROUTES.get_or_init(|| std::sync::RwLock::new(HashMap::new()))
}
```

Event loop:

```rust
if let Ok(routes) = routes().read() {
    if let Some(action) = routes.get(&event.id) {
        match action {
            Action::Main => { /* ... */ }
            Action::Notes => { /* ... */ }
            Action::Ai => { /* ... */ }
            Action::Script(path) => { /* ... */ }
        }
    }
}
```

Update path:

* When you register/unregister anything (main/notes/ai/scripts), update the same routing table under a write lock.

This immediately fixes the biggest “script hotkey hot-reload can’t work” problem.

---

### 5.5 Make script hotkey hot-reload a “replace snapshot” operation

Instead of “update one script at a time” with three maps and a lot of edge cases, use:

* A struct that holds *both* maps and all `HotKey`s
* A method `replace_all(desired: HashMap<Path, Shortcut>)`

Example state:

```rust
struct ScriptHotkeys {
    by_path: HashMap<String, RegisteredScriptHotkey>,
    by_id: HashMap<u32, String>,
}

struct RegisteredScriptHotkey {
    shortcut: String,
    hotkey: HotKey,
    id: u32,
}
```

Then:

```rust
impl ScriptHotkeys {
    fn replace_all(
        &mut self,
        manager: &GlobalHotKeyManager,
        desired: HashMap<String, String>, // path -> shortcut
    ) -> anyhow::Result<()> {
        // 1) Remove paths not present anymore
        let to_remove: Vec<String> = self.by_path
            .keys()
            .filter(|p| !desired.contains_key(*p))
            .cloned()
            .collect();

        for path in to_remove {
            self.unregister_one(manager, &path)?;
        }

        // 2) Add or change existing
        for (path, new_shortcut) in desired {
            match self.by_path.get(&path) {
                Some(reg) if reg.shortcut == new_shortcut => continue, // unchanged
                Some(_) => self.rebind_one(manager, &path, &new_shortcut)?, // changed
                None => self.register_one(manager, &path, &new_shortcut)?, // new
            }
        }

        Ok(())
    }

    fn register_one(&mut self, manager: &GlobalHotKeyManager, path: &str, shortcut: &str) -> anyhow::Result<()> {
        let (mods, code) = shortcuts::parse_shortcut(shortcut)
            .ok_or_else(|| anyhow::anyhow!("Failed to parse shortcut: {}", shortcut))?;
        let hotkey = HotKey::new(Some(mods), code);
        let id = hotkey.id();
        manager.register(hotkey).map_err(|e| anyhow::anyhow!("{e}"))?;

        self.by_id.insert(id, path.to_string());
        self.by_path.insert(path.to_string(), RegisteredScriptHotkey {
            shortcut: shortcut.to_string(),
            hotkey,
            id,
        });
        Ok(())
    }

    fn unregister_one(&mut self, manager: &GlobalHotKeyManager, path: &str) -> anyhow::Result<()> {
        if let Some(reg) = self.by_path.remove(path) {
            self.by_id.remove(&reg.id);
            manager.unregister(reg.hotkey).map_err(|e| anyhow::anyhow!("{e}"))?;
        }
        Ok(())
    }

    fn rebind_one(&mut self, manager: &GlobalHotKeyManager, path: &str, new_shortcut: &str) -> anyhow::Result<()> {
        // transactional-ish: register new first, then swap, then unregister old
        let old = self.by_path.get(path).cloned().ok_or_else(|| anyhow::anyhow!("Missing path"))?;

        let (mods, code) = shortcuts::parse_shortcut(new_shortcut)
            .ok_or_else(|| anyhow::anyhow!("Failed to parse shortcut: {}", new_shortcut))?;
        let new_hotkey = HotKey::new(Some(mods), code);
        let new_id = new_hotkey.id();

        manager.register(new_hotkey).map_err(|e| anyhow::anyhow!("{e}"))?;

        // commit: update maps
        self.by_id.remove(&old.id);
        self.by_id.insert(new_id, path.to_string());
        self.by_path.insert(path.to_string(), RegisteredScriptHotkey {
            shortcut: new_shortcut.to_string(),
            hotkey: new_hotkey,
            id: new_id,
        });

        // cleanup old
        if let Err(e) = manager.unregister(old.hotkey) {
            logging::log("HOTKEY", &format!("Warning: failed to unregister old script hotkey: {e}"));
        }

        Ok(())
    }
}
```

This approach makes it **very hard** to get the maps out of sync because:

* there’s one place where you mutate them,
* and a single “replace snapshot” method is easy to reason about during hot reload.

---

### 5.6 Make channel sends non-blocking

Swap:

* `send_blocking` → `try_send`
* optionally add a “pending” flag to avoid losing “a press” when channel is full

Example (coalescing):

```rust
static MAIN_PENDING: AtomicBool = AtomicBool::new(false);

fn notify_main_hotkey() {
    if MAIN_PENDING.swap(true, Ordering::Relaxed) {
        return; // already pending
    }
    let _ = hotkey_channel().0.try_send(());
}

// In UI consumer after handling:
MAIN_PENDING.store(false, Ordering::Relaxed);
```

This guarantees:

* hotkeys never block,
* and you’ll process at least one press even under load.

---

## Direct answers to your 5 expert questions

### Q1) Is `OnceLock<Mutex<Option<T>>>` the right pattern?

It works, but it’s a smell when it becomes your core architecture:

* `OnceLock` is fine for “initialize once and live forever”.
* `Mutex<Option<T>>` is usually a workaround for “I want to take/replace/shutdown”, which `OnceLock` doesn’t support.

For your case, you’ll be happier with:

* a single `OnceLock<HotkeyService>` where `HotkeyService` owns everything, or
* a dedicated hotkey thread + command channel (no global mutexes needed).

### Q2) Mixed `Ordering` semantics — SeqCst everywhere?

No. SeqCst everywhere is rarely the right move. For plain “publish a number that other threads read” with no dependent data, `Relaxed` is typically enough.

But: ordering is not your real problem. Your real problem is that registration/unregistration and routing updates are not transactional and not unified.

If you adopt a routing-table swap (or a single-threaded service), you can delete most of the atomics entirely.

### Q3) Safely wrap macOS GCD dispatch?

Yes: use a crate if possible.

* `dispatch2` provides a safe API to run work on the main thread. ([Docs.rs][2])
* If you keep FFI, at least follow the common pattern of `dispatch_get_main_queue()` and use `catch_unwind` in your trampoline. ([Zed][1])

### Q4) Trait/generic to eliminate 3x duplication?

Yes — but I’d go further: don’t use a trait at all. Use a data-driven table:

```rust
struct BuiltinHotkeySlot<'a> {
    name: &'static str,
    cfg: &'a config::HotkeyConfig,
    id: &'static AtomicU32,
    slot: &'a mut Option<HotKey>,
}

for slot in slots {
    rebind_hotkey(manager, slot.slot, slot.id, slot.cfg, slot.name);
}
```

Clean, simple, no type gymnastics.

### Q5) Right cleanup strategy for script hotkeys on hot-reload?

Treat reload as “desired snapshot” and compute a diff:

* unregister removed
* rebind changed
* register new

And make the update transactional per entry (don’t lose the old binding if the new fails). Also ensure the event loop routes using the same shared state you mutate.

---

## Bottom line

If you do only two things, do these:

1. **Create `GlobalHotKeyManager` on the main thread on macOS** (per crate docs).
2. **Unify routing** so dynamic script hotkeys and built-in hotkeys go through the same `event.id → action` mapping, and make updates transactional so you don’t lose working bindings.

Everything else (atomics ordering, duplication) becomes much easier once those are fixed.

[1]: https://zed.dev/blog/zed-decoded-async-rust "Async Rust — Zed's Blog"
[2]: https://docs.rs/dispatch2 "dispatch2 - Rust"
[3]: https://docs.rs/global-hotkey/latest/global_hotkey/hotkey/enum.Code.html "Code in global_hotkey::hotkey - Rust"
[4]: https://docs.rs/global-hotkey/latest/global_hotkey/hotkey/struct.HotKey.html "HotKey in global_hotkey::hotkey - Rust"
