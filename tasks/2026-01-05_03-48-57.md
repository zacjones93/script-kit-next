## 1) Critical issues

### A. `diff_scriptlets` can miss “identity moved” changes (likely bug)

Right now scriptlets are **matched by `name` only**:

```rust
let old_by_name: HashMap<&str, &CachedScriptlet> = ...
```

But `CachedScriptlet` also carries `file_path` (which includes an anchor). If the anchor changes while the name stays the same (very plausible, because `scriptlet_to_cached()` currently uses `scriptlet.command` as the anchor), then:

* The cache entry gets updated with the new `file_path` (good).
* **The diff is empty** (bad) because shortcut/expand/alias didn’t change.
* Any subsystem that uses the diff to update registrations can keep pointing at the *old* `file_path` forever.

This is the most dangerous class of bug in this file because it produces **silent staleness**: no errors, no logs, just “why does my hotkey run the wrong thing?”

**Telltale sign:** the comment says “anchor from scriptlet name” but the code uses `scriptlet.command`:

```rust
// Create file_path with anchor from scriptlet name
let anchor = scriptlet.command.clone();
```

That mismatch screams “identity confusion”.

**Fix options (pick one and make it consistent everywhere):**

* If `name` is the stable identifier → diff must also detect `file_path` changes (or treat them as remove+add).
* If `command` (or anchor) is the stable identifier → diff key should be `command`/anchor (and you should add name-change handling).

---

### B. `mtime != current_mtime` staleness detection will miss real changes

`is_stale()` relies purely on `SystemTime` equality:

```rust
Some(cached) => cached.mtime != current_mtime
```

This can miss edits when:

* filesystem mtime resolution is coarse (edits within same timestamp quantum),
* files are replaced while preserving timestamps (common with some editors, sync tools, `cp -p`, etc.),
* atomic replace patterns preserve metadata unexpectedly.

If you miss staleness, you miss reload, and your UI/registrations go out of sync.

---

### C. Path identity is not enforced (easy to end up with duplicate cache entries)

`ScriptletCache` keys by `PathBuf`, but `update_file()` accepts any `Into<PathBuf>` and does not canonicalize/normalize.

If you ever call it with:

* `~/…` expanded in some places but not others,
* relative vs absolute,
* symlinked paths,

…you can end up caching the same file multiple times under different keys, and staleness/removal won’t behave deterministically.

---

## 2) Performance concerns

### A. `get_scriptlets()` clones *everything*

```rust
pub fn get_scriptlets(&self, ...) -> Option<Vec<CachedScriptlet>> {
    self.files.get(...).map(|f| f.scriptlets.clone())
}
```

That clones:

* the `Vec`
* every `CachedScriptlet`
* every `String` inside each scriptlet

If this is called on the UI thread (or often during hot reload), it’s avoidable churn.

You already have `get_file()` returning `&CachedScriptletFile`; the cloning helper is convenience, but it’s a footgun in a performance-sensitive app.

---

### B. `diff_scriptlets` allocates HashMaps each call

Probably fine for small lists, but if scriptlet bundles get large and you diff often (watcher events, periodic refresh), you’ll feel it.

Two mitigations:

* Only diff when you actually re-parse a file.
* Use a faster hasher (local-only, not attacker-controlled input) if this is in a hot path.

---

### C. Logging every validation error individually can become expensive/noisy

If a user breaks parsing in a way that generates a lot of errors, you will spam logs and potentially slow down reloads.

At minimum: consider aggregation/throttling for repeated identical failures.

---

## 3) API design feedback

### A. Cache API should support “update + diff” in one operation

Right now callers likely do:

1. `old = cache.get_scriptlets(path)` (clones)
2. `cache.update_file(path, mtime, new_scriptlets)`
3. `diff_scriptlets(&old, &new)`

This is clunky and forces clones.

A better API is:

* `upsert_file(...) -> ScriptletDiff`
* `remove_file(...) -> Vec<CachedScriptlet>` (or a diff with removed entries)

That makes it hard to “forget” to unregister old stuff.

---

### B. Staleness check should accept a richer fingerprint than just mtime

Even if you keep mtime, you should strongly consider at least `(mtime, size)` and optionally a platform file-id/inode where available.

For “don’t miss updates”, the gold standard is: **watcher events + re-read on event**, with a periodic sanity rescan as a fallback.

---

### C. Identify scriptlets with an explicit key type

Right now identity is implied by `name` and/or `file_path`. That’s how subtle bugs happen.

Use a `ScriptletKey` newtype (even if it’s just a `String` internally) and make one field “the key”.

---

## 4) Simplification opportunities

### A. The `*Change` structs are repetitive

`ShortcutChange`, `ExpandChange`, `AliasChange` are structurally identical.

You can keep them (explicit is fine), but if you feel the module is growing, consolidate into:

* one generic `FieldChange<T>`
* or one enum-based change list

This isn’t urgent unless the change surface expands (e.g., you add `name_change`, `command_change`, etc.).

---

### B. `CachedScriptletFile.path` is redundant

The map key is already the path. Storing the same path inside the entry is extra memory and an extra place for inconsistency.

---

## 5) Specific recommendations (concrete code changes)

### 5.1 Fix the “file_path/anchor changed but diff is empty” bug

**Minimal, low-risk fix:** keep matching by `name`, but detect `file_path` changes.

Add a change type + field in `ScriptletDiff`:

```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct FilePathChange {
    pub name: String,
    pub old: String,
    pub new: String,
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub struct ScriptletDiff {
    pub added: Vec<CachedScriptlet>,
    pub removed: Vec<CachedScriptlet>,
    pub shortcut_changes: Vec<ShortcutChange>,
    pub expand_changes: Vec<ExpandChange>,
    pub alias_changes: Vec<AliasChange>,
    pub file_path_changes: Vec<FilePathChange>, // NEW
}
```

Update `is_empty()` and `change_count()` accordingly.

Then in `diff_scriptlets`:

```rust
if old_scriptlet.file_path != new_scriptlet.file_path {
    diff.file_path_changes.push(FilePathChange {
        name: new_scriptlet.name.clone(),
        old: old_scriptlet.file_path.clone(),
        new: new_scriptlet.file_path.clone(),
    });
}
```

**Alternative (simpler downstream):** treat a file_path change as remove+add for that scriptlet name. That forces unregister/register, which is often what you want for hotkeys/expands.

---

### 5.2 Decide what the anchor is, and make the code/comment consistent

Right now the comment says “anchor from name” but the code uses `command`.

Pick one:

* If you intend anchors to track the **name**, then generate from `name` and keep `command` separate.
* If you intend anchors to track the **command**, update the comment and ensure downstream systems treat `command` as identity (and then you probably want diff keyed by command or file_path).

At minimum, fix the misleading comment because it masks real bugs.

---

### 5.3 Strengthen staleness detection with a fingerprint (mtime + size)

This is a good “cheap win” without hashing everything.

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct FileFingerprint {
    pub mtime: SystemTime,
    pub size: u64,
}

#[derive(Clone, Debug)]
pub struct CachedScriptletFile {
    pub fingerprint: FileFingerprint,
    pub scriptlets: Vec<CachedScriptlet>,
}
```

Then:

```rust
pub fn is_stale(&self, path: impl AsRef<Path>, current: FileFingerprint) -> bool {
    match self.files.get(path.as_ref()) {
        Some(cached) => cached.fingerprint != current,
        None => true,
    }
}
```

If you later add inode/file-id on macOS, you can extend `FileFingerprint` without changing call sites much.

---

### 5.4 Stop cloning scriptlets by default

Replace:

```rust
pub fn get_scriptlets(&self, ...) -> Option<Vec<CachedScriptlet>>
```

With either:

```rust
pub fn get_scriptlets(&self, path: impl AsRef<Path>) -> Option<&[CachedScriptlet]> {
    self.files.get(path.as_ref()).map(|f| f.scriptlets.as_slice())
}
```

Or—if you need to hand them around across windows/threads—store scriptlets as `Arc<[CachedScriptlet]>`:

```rust
use std::sync::Arc;

pub struct CachedScriptletFile {
    pub fingerprint: FileFingerprint,
    pub scriptlets: Arc<[CachedScriptlet]>,
}

pub fn get_scriptlets(&self, path: impl AsRef<Path>) -> Option<Arc<[CachedScriptlet]>> {
    self.files.get(path.as_ref()).map(|f| f.scriptlets.clone())
}
```

That matches your stated “Arc for zero-copy sharing” pattern.

---

### 5.5 Provide an “update + diff” API to make correctness the default

Example shape:

```rust
use std::collections::hash_map::Entry;

impl ScriptletCache {
    pub fn upsert_file(
        &mut self,
        path: PathBuf,
        fingerprint: FileFingerprint,
        scriptlets: Vec<CachedScriptlet>,
    ) -> ScriptletDiff {
        match self.files.entry(path) {
            Entry::Vacant(v) => {
                let diff = ScriptletDiff { added: scriptlets.clone(), ..Default::default() };
                v.insert(CachedScriptletFile { fingerprint, scriptlets });
                diff
            }
            Entry::Occupied(mut o) => {
                let old_scriptlets = std::mem::replace(&mut o.get_mut().scriptlets, scriptlets);
                let diff = diff_scriptlets(&old_scriptlets, &o.get().scriptlets);
                o.get_mut().fingerprint = fingerprint;
                diff
            }
        }
    }

    pub fn remove_file_with_diff(&mut self, path: &Path) -> Option<Vec<CachedScriptlet>> {
        self.files.remove(path).map(|f| f.scriptlets)
    }
}
```

This ensures the caller can always correctly unregister removed items.

(You may tweak the ownership swaps to avoid extra clones; the above is the general pattern.)

---

### 5.6 Normalize/canonicalize cache keys

You don’t necessarily want to `canonicalize()` on every call (it hits the filesystem), but you *do* want one “path normalization boundary”.

Pragmatic approach:

* Normalize at the point where you enumerate files (initial scan and watcher events).
* Enforce by debug assertions in this module:

```rust
debug_assert!(path.is_absolute(), "ScriptletCache expects absolute paths");
```

If you do need canonicalization, do it once upstream.

---

## Answers to your “Expert Question 13” (broader architecture)

Even though the provided file is scriptlet-only, your questions are really about scripts + scheduler + cache policy. Here’s what I’d do in a performance-sensitive launcher:

### 1) Content hashing vs mtime?

* Don’t replace mtime with SHA256 as your *primary* invalidation trigger. You’d have to read the whole file to hash it, which defeats the point.
* Do use a **fingerprint** (mtime+size+file-id) to decide whether to re-read.
* Once you re-read, optionally compute a **fast hash** (BLAKE3 / xxHash64) so you can cheaply detect “changed metadata but identical content” and skip downstream work.
* Most importantly: rely on **filesystem watcher events** to drive reloads, not “poll and compare mtimes”.

SHA256 is fine but overkill here; you’re not verifying adversarial integrity, you’re invalidating caches.

### 2) Detect/prevent Arc cycles in dependency graphs?

Don’t model dependencies as `Arc<Script>` edges. Model them as **IDs**.

* Central store: `ScriptStore { scripts: HashMap<ScriptId, Arc<Script>> }`
* Script has `deps: Vec<ScriptId>` (or `Vec<PathBuf>`)
* When you need the dependent script, resolve through the store.

If you truly need references, store `Weak<Script>` for edges to break cycles.

Also: detect cycles at load time with a DFS “visiting/visited” stack and surface an error early.

### 3) tree-sitter / real parser for metadata extraction?

Regex parsing TS metadata is always going to be fragile.
Best practical option that keeps performance:

* Define a **small, strict metadata format** (frontmatter-like comment block or JSON) at the top of the file.
* Keep regex only as a compatibility fallback.
* Validate against a schema (even if it’s just “required fields + types + unknown fields warning”).

Using a full TS parser is doable, but it’s heavier than you want in an “instant launcher” unless you parse in the background and cache results.

### 4) Right caching strategy (LRU? Weak refs?)

For scripts:

* Keep an always-resident **index**: path → metadata + fingerprint + last-seen info.
* Cache loaded script bodies as `Arc<Script>` behind an LRU keyed by ScriptId/path.
* Store `Weak<Script>` in the index to avoid pinning huge content forever, or let the LRU own the strong refs.

For scriptlets:

* They’re small; cache all parsed results.
* Use watcher-driven incremental updates + diffs (like you’re doing), but fix identity issues.

### 5) Scheduled tasks handling script updates?

Never store a long-lived `Arc<Script>` inside the scheduler if you expect live updates.
Store:

* `ScriptId/path + expected fingerprint`
  On execution:
* resolve from cache/store
* if fingerprint changed, reload/refresh before running

If you have a watcher, you can also proactively refresh scheduled entries when the file changes, but still validate on execution (because watchers can miss events).

---

If you implement only two changes from this review, do these first:

1. **Fix diff identity so file_path/anchor changes aren’t invisible.**
2. **Stop relying on mtime alone** (fingerprint + watcher-driven reload).
