## 1) Critical issues

### 1. `MouseEventData` is **buggy / ambiguous** (`#[serde(untagged)]`)

In `types.rs`:

```rust
#[serde(untagged)]
pub enum MouseEventData {
  Move { x: f64, y: f64 },
  Click { x: f64, y: f64, button: Option<String> },
  SetPosition { x: f64, y: f64 },
}
```

`Move {x,y}` and `SetPosition {x,y}` are **the same shape**, so Serde will deserialize `{ "x": 1, "y": 2 }` as the **first matching variant** (`Move`) every time. `SetPosition` is effectively unreachable.

Even if you’re not currently using `MouseEventData` on the wire (your `Message::Mouse` uses `Option<serde_json::Value>`), this will bite you the moment you try to “make mouse typed.”

**Fix:** don’t use untagged when variants overlap. Either:

* collapse into a single struct (`x,y,button?`) and let `action` decide semantics, or
* use a tagged enum (but then don’t also have `action`).

I give concrete code below.

---

### 2. Top-level `Message` has **no forward-compatibility story**

You added `Unknown` fallbacks for *nested* enums (`ElementType`, `LayoutComponentType`), which is good.

But the top-level protocol:

```rust
#[serde(tag = "type")]
pub enum Message { ... }
```

…will **hard-fail** on any unknown `"type"`. That means:

* newer SDK sending a new message type → older app crashes/desyncs
* newer app sending a new message type → older SDK crashes/desyncs

This is *the* thing that will destroy “backwards compatibility” over time.

**Fix:** add a wire-level “unknown message” catch. With `#[serde(tag="type")]` you can’t trivially do `#[serde(other)]` the way you did with string enums. You either:

* implement a small “envelope” parser (`type` + raw `Value`) and then deserialize known messages, or
* introduce a v2 envelope protocol that can carry unknown payloads without failing.

---

### 3. Result typing is inconsistent (`ForceSubmit` vs `Submit`)

* `ForceSubmit { value: serde_json::Value }` implies “submit can be any JSON”.
* `Submit { id: String, value: Option<String> }` implies “submit result is only a string”.

That mismatch will either:

* force you into “stringified JSON” hacks (hard to reason about and easy to double-encode), or
* silently lose type information.

It also blocks obvious features:

* `select(multiple: true)` wants to return an array
* `fields`/`form` want to return an object

**Fix:** make `Submit.value` support JSON, in a backwards-compatible way (details below).

---

### 4. “Typed holes” (`serde_json::Value`) are drifting your protocol already

You defined strong types like `ExecOptions`, `MouseEventData`, but on the wire you still do:

* `Exec { options: Option<serde_json::Value> }` (instead of `ExecOptions`)
* `Mouse { data: Option<serde_json::Value> }` (instead of `MouseEventData` / something consistent)
* `Div.container_padding: Option<serde_json::Value>` (probably intentional polymorphism, but still a hole)

This is a correctness problem as much as “type safety”: the Rust and TS sides can drift and you won’t know until runtime.

**Fix:** use typed structs *plus* an `extra` field via `#[serde(flatten)]` to preserve forward-compatibility.

---

### 5. Semantic IDs are not stable in the face of reordering

You’re generating choice semantic IDs like:

> `choice:{index}:{value_slug}`

Index-based IDs break if:

* choices reorder (sorting, ranking, fuzzy match updates)
* choices are inserted/removed
* duplicates exist and positions change

If you want “AI-driven UX targeting,” IDs must be stable under *UI transformations*.

**Fix:** base element IDs on a stable key (explicit `key`, or deterministic hash/UUID v5) rather than index.

---

## 2) Performance concerns (protocol-side)

### 1. Base64 payloads in JSON (screenshots) can spike memory and stall

`screenshotResult.data: String` base64 PNG is going to:

* allocate a huge `String`
* allocate again when encoding/decoding
* blow up line lengths (JSONL framing becomes fragile)

If you allow `hiDpi: true`, this gets worse fast.

**Recommendation:** return a file path (temp file) or shared-memory handle instead of base64 for large blobs. If you must keep base64, add:

* a max payload size guard
* an error response when it would exceed it
* a “preferFile: true” option

---

### 2. High-frequency `update` messages + full JSON parse can cause jank

If scripts send `update` on every keystroke and you parse on the UI thread, you will lose 60fps.

**Recommendation:**

* parse IO off the UI thread
* throttle/debounce high-frequency updates (coalesce “last update wins” per prompt id)
* consider “diff-ish” messages if editor updates get heavy

---

### 3. `serde_json::Value` in hot paths creates extra allocations

Every `Value` map/object creates heap allocations and string keys. You’ll pay this repeatedly for things like `Update`, untyped options, and any polymorphic payload.

**Recommendation:**

* keep `Value` only where the payload is truly open-ended
* for everything else, use typed structs with `#[serde(flatten)] extra` to preserve unknown fields without losing typing

---

## 3) API design feedback (including your 5 expert questions)

### Q1) Split enum into trait objects?

**Don’t replace the wire enum with trait objects.** Deserializing into trait objects is painful, and you’ll lose most of the benefits you currently get from Serde.

What you *actually* want is **extensible routing**, not “trait objects for messages.”

Best pattern here:

* keep strongly-typed message structs (for correctness + performance)
* route by `type` string into handler registry (for extensibility)
* have an `Unknown` fallback so new message types don’t blow up old versions

You can do that without rewriting everything into trait objects.

---

### Q2) Versioning strategy for JSONL?

For JSONL protocols, the cleanest is:

1. **Optional hello handshake** (capabilities + protocol version)

* New SDK/app sends it first
* Old SDK/app doesn’t; you infer “v1”

2. **Capability flags**, not just a single integer version
   Because your real problem is “does the other side support feature X” (semantic IDs v2, submit JSON values, exec result, etc.), not “protocol = 2”.

Example:

```json
{"type":"hello","protocol":1,"sdkVersion":"x.y.z","capabilities":["submitJson","unknownTypeOk","semanticIdV2"]}
```

```json
{"type":"helloAck","protocol":1,"capabilities":["submitJson","semanticIdV2"]}
```

This lets you ship features incrementally without breaking scripts.

---

### Q3) Use a schema definition language as source of truth?

Yes. Otherwise Rust/TS will drift.

Given you’re already “Serde-first” in Rust, the pragmatic path is:

* **Rust is the source of truth**
* Generate TS types from Rust in CI/build (tools exist to export TS typings from Rust types)
* Optionally generate JSON Schema too for runtime validation *in tests* (not in release builds)

Avoid protobuf for this use case. Protobuf solves different problems (binary, strong schema) and tends to fight “JSON over stdin/stdout” ergonomics.

---

### Q4) Backwards compatibility when removing deprecated variants?

**Don’t remove them** on the wire until you’re willing to break scripts.

Instead:

* mark deprecated in TS SDK
* keep Rust support indefinitely, or at least for a long deprecation window
* internally map old variants into new internal representation

If you *must* consolidate, you can:

* keep old `type` strings as aliases during deserialization (or manual routing)
* emit only the new message types going forward

---

### Q5) Is request/response correlation worth implementing?

Yes — and you’ve already started (`requestId` exists).

What’s missing is consistency and a clean mental model.

The model that scales is:

* **Notification**: fire-and-forget (no `requestId`)
* **Request**: has `requestId`
* **Response**: echoes that `requestId`

This becomes mandatory once:

* requests can be in-flight concurrently
* responses can arrive out of order
* you have multiple windows/targets

Even if you keep the current message shapes, make this rule explicit and apply it across the protocol.

---

## 4) Simplification opportunities

### 1. Collapse “nearly identical prompts”

You have multiple variants that are conceptually the same:

* `Arg`, `Mini`, `Micro` (same fields)
* `SetPanel`, `SetPreview`, `SetPrompt` (same fields)

If you keep them for compatibility, you can still simplify **internally** by normalizing to one struct:

```rust
enum PromptKind { Arg, Div, Editor, /* ... */ }
enum Density { Normal, Mini, Micro }

struct Prompt {
  id: String,
  kind: PromptKind,
  density: Density,
  payload: PromptPayload,
}
```

Then your renderer sees one normalized prompt.

---

### 2. Normalize “result” messages

You have a lot of “Result-ish” messages (`TextSet`, `WindowActionResult`, `ClipboardHistoryResult`, `MenuActionResult`, etc.) with repeated `success` + `error`.

That’s fine, but it’s repetitive and grows your enum.

Internally (again, without breaking wire format), normalize:

```rust
struct OpResult<T> {
  request_id: String,
  ok: bool,
  error: Option<String>,
  data: Option<T>,
}
```

Then each handler returns `OpResult<T>`.

---

### 3. Make “targeting / window routing” explicit (if multi-window touches protocol)

If any of these messages can apply to a non-main window, you’ll eventually need a `target` field:

* which window?
* which surface/panel?
* which prompt session?

If you don’t need it today, fine — but keep room for it in v2 or as optional fields.

---

## 5) Specific recommendations (concrete code changes + examples)

### Recommendation A: Add forward-compatible wire parsing **now**

Even if you keep `Message` enum as-is, stop deserializing directly into it as your only step.

**Pattern: “Raw envelope → typed decode if known → Unknown fallback.”**

```rust
use serde::Deserialize;
use serde_json::Value;

#[derive(Debug, Deserialize)]
struct RawMessage {
    #[serde(rename = "type")]
    ty: String,
    #[serde(flatten)]
    rest: Value,
}

#[derive(Debug)]
enum Inbound {
    Known(Message),
    Unknown { ty: String, raw: Value },
}

fn decode_line(line: &str) -> Result<Inbound, serde_json::Error> {
    let raw: RawMessage = serde_json::from_str(line)?;

    // Fast path: if it's a known type, deserialize into the enum.
    // If not known, preserve it.
    let is_known = matches!(
        raw.ty.as_str(),
        "arg" | "div" | "editor" | "submit" | "update" | "exit"
        | "forceSubmit" | "setInput"
        // ... list the types you actually support ...
    );

    if !is_known {
        return Ok(Inbound::Unknown { ty: raw.ty, raw: raw.rest });
    }

    // Reconstruct the original object including the type field so the enum can decode.
    let mut obj = match raw.rest {
        Value::Object(map) => map,
        other => {
            // Malformed (non-object). Treat as unknown or error.
            return Ok(Inbound::Unknown { ty: raw.ty, raw: other });
        }
    };
    obj.insert("type".into(), Value::String(raw.ty));

    let msg: Message = serde_json::from_value(Value::Object(obj))?;
    Ok(Inbound::Known(msg))
}
```

**Why this matters:**

* unknown message types no longer crash your protocol
* you can introduce new message types safely
* you get a clean place to implement deprecation/alias mapping later

---

### Recommendation B: Fix mouse typing (remove the ambiguous enum)

Option 1 (best with your current wire shape): keep `action`, make `data` a single struct.

```rust
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct MouseData {
    pub x: f64,
    pub y: f64,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub button: Option<String>,
}
```

Then in `Message::Mouse`:

```rust
#[serde(rename = "mouse")]
Mouse {
    action: MouseAction,
    #[serde(skip_serializing_if = "Option::is_none")]
    data: Option<MouseData>,
},
```

Now:

* no ambiguous decode
* `action` decides whether `button` is used
* TS types become simple

Option 2: remove `action` and make the enum tagged by `action` (cleaner, but wire-breaking).

---

### Recommendation C: Make `Submit.value` JSON-capable without breaking old scripts

Change:

```rust
Submit { id: String, value: Option<String> }
```

to:

```rust
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SubmitValue {
    Text(String),
    Json(serde_json::Value),
}

#[serde(rename = "submit")]
Submit { id: String, #[serde(skip_serializing_if = "Option::is_none")] value: Option<SubmitValue> },
```

**Compatibility behavior:**

* old payloads with `"value": "abc"` still decode as `Text("abc")`
* new payloads can send `"value": ["a","b"]` or `{...}`

On the TS side, you type `value: string | unknown` (or better: `string | number | boolean | object | any[] | null`) and normalize in SDK.

This aligns with your existing `ForceSubmit { value: Value }` and unlocks multi-select and forms sanely.

---

### Recommendation D: Replace `serde_json::Value` “typed holes” with typed + `extra`

For options/params that are “mostly known but extensible”, do this:

```rust
#[derive(Clone, Debug, Default, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct ExecOptions {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwd: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub env: Option<std::collections::HashMap<String, String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout: Option<u64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_stdout: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub capture_stderr: Option<bool>,

    #[serde(flatten)]
    pub extra: std::collections::BTreeMap<String, serde_json::Value>,
}
```

Then use it directly:

```rust
#[serde(rename = "exec")]
Exec {
    command: String,
    #[serde(default)]
    options: ExecOptions,
},
```

Now:

* you get real typing
* you don’t break forward-compat when new fields are added
* TS generation becomes reliable

Repeat this pattern for other `Value` fields that are supposed to stabilize.

---

### Recommendation E: Introduce a deterministic semantic ID scheme (stop using index)

**Goal:** stable element IDs even if the list reorders/filters.

Practical approach that doesn’t force script changes:

* add an optional `key` (or `semanticId`) on `Choice`
* if absent, derive deterministically from `value` (and maybe `name`) using a hash or UUID v5

Example:

```rust
// New (optional) stable key from script; doesn't break old scripts.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Choice {
    pub name: String,
    pub value: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    #[serde(default, skip_serializing_if = "Option::is_none", rename = "key")]
    pub key: Option<String>,

    #[serde(skip_serializing_if = "Option::is_none", rename = "semanticId")]
    pub semantic_id: Option<String>,
}
```

Then generate semantic IDs like:

* if `semanticId` provided → use it
* else if `key` provided → `choice:{key}`
* else → `choice:{hash(value)}` (or uuid v5)

This makes IDs stable under reorder and filter.

---

### Recommendation F: Standardize request/response correlation rules

You already use `requestId` in many places. Make it systematic:

* Any operation that returns something **must** have `requestId`
* Any response **must** echo `requestId`
* Fire-and-forget messages **must not** pretend to be requests

Then fill the gaps. Examples to consider:

* If `clipboard read` returns data, you need a `clipboardResult { requestId, content, format }`
* If `exec` is meant to return output/exit code, add `execResult`

If they’re truly fire-and-forget, that’s fine — but then don’t include “capture stdout” options with no way to get the stdout back.

---

### Recommendation G: Add an optional hello handshake (version + capabilities)

Minimal, low-risk, high payoff.

Add:

```rust
#[serde(rename = "hello")]
Hello {
    protocol: u32,
    #[serde(rename = "sdkVersion")]
    sdk_version: String,
    #[serde(default)]
    capabilities: Vec<String>,
}

#[serde(rename = "helloAck")]
HelloAck {
    protocol: u32,
    #[serde(default)]
    capabilities: Vec<String>,
}
```

Make it optional:

* if first message is `hello`, negotiate
* otherwise assume legacy defaults

This gives you a clean place to gate new features like `submitJson`, `semanticIdV2`, `unknownTypeOk`, etc.

---

## What I’d do first (highest ROI in order)

1. **Implement raw-envelope parsing** so unknown message types don’t kill you.
2. Fix `MouseEventData` (or delete it until you can type it correctly).
3. Make `Submit.value` JSON-capable (untagged enum) to unblock forms/multi-select cleanly.
4. Convert `Exec.options` and other `Value` holes into typed + `extra` to stop protocol drift.
5. Implement deterministic semantic IDs not based on list index.
6. Add hello/capabilities handshake so you can evolve without breaking scripts.

If you want, I can also propose a clean “v2 envelope” (JSON-RPC-ish) that you can layer on top without breaking v1 scripts — but the steps above already remove the biggest failure modes while keeping your current wire format intact.
